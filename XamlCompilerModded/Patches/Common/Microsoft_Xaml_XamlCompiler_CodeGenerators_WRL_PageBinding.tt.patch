diff --git a/Microsoft/Xaml/XamlCompiler/CodeGenerators/WRL_PageBinding.tt b/Microsoft/Xaml/XamlCompiler/CodeGenerators/WRL_PageBinding.tt
new file mode 100644
index 0000000..5f3416c
--- /dev/null
+++ b/Microsoft/Xaml/XamlCompiler/CodeGenerators/WRL_PageBinding.tt
@@ -0,0 +1,1573 @@
+ï»¿<#@ template language="C#" inherits="WRL_CodeGenerator<PageDefinition>" visibility="internal" linePragmas="false"#>
+<#@ import namespace="System.Collections.Generic" #>
+<#@ import namespace="System.Linq" #>
+<#@ import namespace="Microsoft.UI.Xaml.Markup.Compiler" #>
+<#@ import namespace="Microsoft.UI.Xaml.Markup.Compiler.CodeGen" #>
+<#@ import namespace="Microsoft.Windows.UI.Xaml.Build.Tasks.Utilities" #>
+<#@ import namespace="Microsoft.Xaml.DirectUI" #>
+<#@ import namespace="Microsoft.Xaml.XamlDom" #>
+<#
+    BindUniverse bindUniverse = Arguments[0] as BindUniverse;
+#>
+    class <#=Model.CodeInfo.ClassName.ShortName#>::<#=bindUniverse.BindingsClassName#>
+        : public <#=Globalize(ProjectInfo.RootNamespace)#>::<#=bindUniverse.DataRootType.NeedsBoxUnbox() ? "ValueTypeXamlBindings" : "ReferenceTypeXamlBindings"#><<#=bindUniverse.DataRootType.WRLNameInterface()#>, <#=GetBindingTrackingClassName(bindUniverse, Model.CodeInfo)#>>
+<#  if (bindUniverse.NeedsBindingsTracking) { #>
+        , public <#=Globalize(ProjectInfo.RootNamespace)#>::IXamlBindingTracking
+<#  }#>
+    {
+public:
+        <#=bindUniverse.BindingsClassName#>(HRESULT* phr)
+        {
+<#  if (bindUniverse.NeedsBindingsTracking) {#>
+            *phr = InitializeTracking(this);
+<#  } else { #>
+            *phr = S_OK;
+<#  }#>
+        }
+
+<#  if (bindUniverse.NeedsBindingsTracking) { #>
+        ~<#=bindUniverse.BindingsClassName#>() override
+        {
+            <#=bindUniverse.BindingsClassName#>::ReleaseAllListeners();
+        }
+
+<#  }#>
+        HRESULT Connect(int connectionId, IInspectable* target) override
+        {
+            HRESULT hr = S_OK;
+
+            switch (connectionId)
+            {
+<# foreach (var element in bindUniverse.ElementsWithConnectCase) { #>
+            case <#=element.ConnectionId#>: // <#=element.LineNumberAndXamlFile#>
+                {
+<#               if (element.Type.IsDerivedFromControlTemplate())#>
+<#               {#>
+                    hr = Update(); // Template children have been connected, initialize bindings
+<#               }#>
+<#               else#>
+<#               {#>
+<#      Output_ConnectionId_Case(element); #>
+<#               }#>
+                }
+                break;
+<# } #>
+            }
+
+            return hr;
+        }
+
+        HRESULT DisconnectUnloadedObject(int connectionId) override
+        {
+<#      if (bindUniverse.ElementsWithDisconnectCase.Count() == 0) { #>
+            return E_INVALIDARG;
+<#      } else { #>
+            HRESULT hr = S_OK;
+
+            switch (connectionId)
+            {
+<#          foreach (var element in bindUniverse.ElementsWithDisconnectCase) { #>
+                case <#=element.ConnectionId#>: // <#=element.LineNumberAndXamlFile#>
+                    {
+<#              if (bindUniverse.BoundElements.Contains(element)) { #>
+<#              Output_ApiInformationCall_Push(element.ApiInformation, Indent.OneTab); #>
+                        if (<#=element.ObjectCodeName#>)
+                        {
+<#              foreach (var ba in element.BindAssignments.Where(ba => ba.HasDeferredValueProxy)) { #>
+                            <#=ba.ObjectDeferredAssignmentCodeName#> = <#=element.GetMemberGetExpression(ba)#>;
+<#              }#>
+                            <#=element.ObjectCodeName#> = nullptr;
+                        }
+<#              foreach (var childElem in element.Children.Where(c => bindUniverse.ElementsWithDisconnectCase.Contains(c))) {#>
+                        DisconnectUnloadedObject(<#=childElem.ConnectionId#>);
+<#              }#>
+<#              Output_ApiInformationCall_Pop(element.ApiInformation, Indent.OneTab); #>
+<#              } #>
+<#              if (element.HasRootNamedElementStep) { #>
+                    this->UnloadableBindingSourcesToUpdate.push_back([this]()
+                    {
+<#                  PushIndent(Indent.TwoTabs); #>
+<#                  Output_Custom_Update_Call(element.RootNamedElementStep, "nullptr", "nullptr", KnownStrings.NotPhased);#>
+<#                  PopIndent(); #>
+                            });
+<#              } #>
+                }
+                break;
+<#          }#>
+                default:
+                    hr = E_INVALIDARG;
+                    break;
+            }
+
+            return hr;
+<#      } #>
+        }
+<#  if (bindUniverse.ElementsWithBoundLoadAssignments.Any()) { #>
+
+        HRESULT UpdateUnloadedElement(int connectionId)
+        {
+            HRESULT hr = S_OK;
+
+            switch (connectionId)
+            {
+<#      foreach (var element in bindUniverse.ElementsWithBoundLoadAssignments) { #>
+            case <#=element.ConnectionId#>: // <#=element.LineNumberAndXamlFile#>
+                {
+<#          foreach (var ba in element.BindAssignments.OfType<BoundLoadAssignment>()) { #>
+<#              PushIndent(Indent.TwoTabs); #>
+<#              Output_Binding_SetValue_Non_Function_Call(ba, ba.ObjectDeferredAssignmentCodeName, false); #>
+<#              PopIndent(); #>
+<#          } #>
+                    }
+                    break;
+<#      }#>
+            default:
+                hr = E_INVALIDARG;
+                break;
+            }
+
+            return hr;
+        }
+<#  }#>
+<#  if (bindUniverse.NeedsIDataTemplateExtension) {#>
+<#      var phaseAssignments = bindUniverse.PhaseAssignments.Where(kvp => kvp.Key != 0).OrderBy(kvp => kvp.Key).ToArray();#>
+
+        HRESULT Recycle() override
+        {
+            HRESULT hr = S_OK;
+
+<#      if (bindUniverse.NeedsBindingsTracking) { #>
+            hr = ReleaseAllListeners();
+            if (FAILED(hr)) return hr;
+
+<#      } #>
+<#      if (phaseAssignments.Length != 0) { #>
+            ::Microsoft::WRL::ComPtr<<#=Projection(DUI.NamespaceWindowsUIXamlMarkup)#>::IXamlBindingHelperStatics> xamlBindingHelperStatics;
+            hr = ::ABI::Windows::Foundation::GetActivationFactory(
+                ::Microsoft::WRL::Wrappers::HStringReference(RuntimeClass_Windows_UI_Xaml_Markup_XamlBindingHelper).Get(),
+                &xamlBindingHelperStatics);
+            if (FAILED(hr)) return hr;
+
+<#      } #>
+<#      foreach (KeyValuePair<int, List<PhaseAssignment>> kvp in phaseAssignments) { #>
+<#          foreach(PhaseAssignment phase in kvp.Value) { #>
+            {
+                HRESULT hrT = hr;
+<#              PushIndent(Indent.FourTabs);#>
+<#=phase.ConnectionIdElement.ReferenceExpression#>
+<#              PopIndent();#>
+                hr = hrT;
+                if (FAILED(hr)) return hr;
+
+<#              if (phase.ConnectionIdElement.CanBeInstantiatedLater) { #>
+                if (_ConnectionIdElement_Reference)
+                {
+<#                  PushIndent();#>
+<#              }#>
+                hrT = hr;
+<#              PushIndent(Indent.FourTabs);#>
+<#=phase.ConnectionIdElement.Type.WRLDeclareQIIfNeeded($"{Projection(DUI.NamespaceWindowsUIXaml)}::IUIElement", "_ConnectionIdElement_Reference", "pUIElement")#>
+<#              PopIndent();#>
+                hr = hrT;
+                if (FAILED(hr)) return hr;
+
+                hr = xamlBindingHelperStatics->SuspendRendering(pUIElement);
+                if (FAILED(hr)) return hr;
+<#              if (phase.ConnectionIdElement.CanBeInstantiatedLater) { #>
+<#                  PopIndent();#>
+                }
+<#              }#>
+            }
+<#          } #>
+<#      } #>
+
+            return hr;
+        }
+
+        HRESULT ProcessBindings(IInspectable* item, int itemIndex, int phase, int* nextPhase) override
+        {
+            *nextPhase = -1;
+            HRESULT hr = S_OK;
+
+<#      if (phaseAssignments.Length != 0) { #>
+            ::Microsoft::WRL::ComPtr<<#=Projection(DUI.NamespaceWindowsUIXamlMarkup)#>::IXamlBindingHelperStatics> xamlBindingHelperStatics;
+            hr = ::ABI::Windows::Foundation::GetActivationFactory(
+                ::Microsoft::WRL::Wrappers::HStringReference(RuntimeClass_Windows_UI_Xaml_Markup_XamlBindingHelper).Get(),
+                &xamlBindingHelperStatics);
+            if (FAILED(hr)) return hr;
+
+<#      } #>
+            switch (phase)
+            {
+            case 0:
+                {
+                    *nextPhase = <#=bindUniverse.GetNextPhase(0)#>;
+                    bool fSetIgnored;
+                    hr = SetDataRoot(item, &fSetIgnored);
+                    if (FAILED(hr)) return hr;
+
+                    if (_dataContextChangedToken.value != 0)
+                    {
+                        HRESULT hrT = hr;
+<#      PushIndent(Indent.SixTabs);#>
+<#=bindUniverse.RootElement.ReferenceExpression#>
+<#      PopIndent();#>
+                        hr = hrT;
+                        if (FAILED(hr)) return hr;
+
+                        {
+                            hrT = hr;
+<#      PushIndent(Indent.SevenTabs);#>
+<#=bindUniverse.RootElement.Type.WRLDeclareQIIfNeeded($"{Projection(DUI.NamespaceWindowsUIXaml)}::IFrameworkElement2", "_ConnectionIdElement_Reference", "pFE2")#>
+<#      PopIndent();#>
+                            hr = hrT;
+                            if (FAILED(hr)) return hr;
+
+                            hr = pFE2->remove_DataContextChanged(_dataContextChangedToken);
+                            if (FAILED(hr)) return hr;
+                        }
+
+                        _dataContextChangedToken.value = 0;
+                    }
+
+                    _isInitialized = true;
+                 }
+                 break;
+<#      foreach(KeyValuePair<int, List<PhaseAssignment>> kvp in phaseAssignments) { #>
+            case <#=kvp.Key#>:
+                {
+<#          foreach(PhaseAssignment phase in kvp.Value) { #>
+                    {
+                        HRESULT hrT = hr;
+<#              PushIndent(Indent.SixTabs);#>
+<#=phase.ConnectionIdElement.ReferenceExpression#>
+<#              PopIndent();#>
+                        hr = hrT;
+                        if (FAILED(hr)) return hr;
+
+<#              if (phase.ConnectionIdElement.CanBeInstantiatedLater) { #>
+                        if (_ConnectionIdElement_Reference)
+                        {
+<#                  PushIndent();#>
+<#              }#>
+                        hrT = hr;
+<#              PushIndent(Indent.FourTabs);#>
+<#=phase.ConnectionIdElement.Type.WRLDeclareQIIfNeeded($"{Projection(DUI.NamespaceWindowsUIXaml)}::IUIElement", "_ConnectionIdElement_Reference", "pUIElement")#>
+<#              PopIndent();#>
+                        hr = hrT;
+                        if (FAILED(hr)) return hr;
+
+                        hr = xamlBindingHelperStatics->ResumeRendering(pUIElement);
+                        if (FAILED(hr)) return hr;
+<#              if (phase.ConnectionIdElement.CanBeInstantiatedLater) { #>
+<#                  PopIndent();#>
+                        }
+<#              }#>
+                    }
+<#          } #>
+                    *nextPhase = <#=bindUniverse.GetNextPhase(kvp.Key)#>;
+                }
+                break;
+<#      } #>
+            }
+
+            if (SUCCEEDED(hr))
+            {
+                <#=bindUniverse.RootStep.ValueType.WRLDeclareSmartVar("objT")#>
+                hr = TroleBoxer::UnboxValue(item, <#=bindUniverse.RootStep.ValueType.WRLOutParam("objT")#>);
+                if (SUCCEEDED(hr))
+                {
+                    hr = Update_(<#=bindUniverse.RootStep.ValueType.WRLGetSmartVar("objT")#>, 1 << phase);
+                }
+            }
+
+            return hr;
+        }
+<# } else if (bindUniverse.NeedsIDataTemplateComponent) { #>
+        HRESULT Recycle() override
+        {
+            return S_OK;
+        }
+
+        HRESULT ProcessBindings(IInspectable* item, int itemIndex, int phase, int* nextPhase) override
+        {
+            *nextPhase = 1;
+            return S_OK;
+        }
+<# } #>
+
+<# if (bindUniverse.DistinctConvertersUsed.Count() > 0) { #>
+<#     if (Model.CodeInfo.IsResourceDictionary) { #>
+        void SetConverterLookupRoot(<#=Projection(DUI.NamespaceWindowsUIXaml)#>::ResourceDictionary const& resources)
+        {
+            localResources = resources;
+        }
+<#     } else { #>
+        void SetConverterLookupRoot(<#=Projection(DUI.NamespaceWindowsUIXaml)#>::FrameworkElement const& rootElement)
+        {
+            converterLookupRoot = rootElement;
+        }
+<#     }#>
+
+        <#=Projection(DUI.NamespaceWindowsUIXamlData)#>::IValueConverter LookupConverter(::winrt::hstring const& key)
+        {
+<#      if (!Model.CodeInfo.IsResourceDictionary) { #>
+            if (!localResources)
+            {
+                localResources = converterLookupRoot.get().Resources();
+                converterLookupRoot = nullptr;
+            }
+<#      }#>
+            auto boxedKey = ::winrt::box_value(key);
+            return (localResources.HasKey(boxedKey) ? localResources.Lookup(boxedKey) : <#=Projection(DUI.NamespaceWindowsUIXaml)#>::Application::Current().Resources().Lookup(boxedKey))
+                .as<<#=Projection(DUI.NamespaceWindowsUIXamlData)#>::IValueConverter>();
+        }
+<#  }#>
+
+    private:
+<#  if (bindUniverse.BoundElements != null && bindUniverse.BoundElements.Any()) { #>
+        // Fields for each control that has bindings.
+<#  }#>
+<#  foreach (ConnectionIdElement bindElement in bindUniverse.BoundElements) { #>
+<#      if (bindElement.IsWeakRef) { #>
+        ::Microsoft::WRL::WeakRef <#=bindElement.ObjectCodeName#>; // <#=bindElement.Type.WRLNameInterface()#>
+<#      } else if (!bindElement.Type.IsDerivedFromControlTemplate()) { #>
+        ::Microsoft::WRL::ComPtr<<#=bindElement.Type.WRLNameInterface()#>> <#=bindElement.ObjectCodeName#>;
+<#      }#>
+<#      if (bindElement.CanBeInstantiatedLater) { #>
+<#          foreach (var ba in bindElement.BindAssignments) { #>
+        <#=ba.MemberType.WRLName()#> <#=ba.ObjectDeferredAssignmentCodeName#> <#=ba.MemberType.IsNullable ? "{nullptr}" : "{}"#>;
+<#          } #>
+<#      } #>
+<#  } #>
+<#  if (bindUniverse.UnloadableBindingSourceElements.Any()) { #>
+        CCoSimpleArray<std::function<void ()>> UnloadableBindingSourcesToUpdate;
+<#  } #>
+<#  if (bindUniverse.ElementsWithBoundLoadAssignments.Any()) { #>
+        CCoSimpleArray<int> UnloadedElementsToUpdate;
+<#  } #>
+<#  if (bindUniverse.NeedsBindingsTracking) { #>
+
+        // Fields for binding tracking.
+<#      Output_Listener_Tracking_Fields(bindUniverse);#>
+<#  }#>
+<#  if (bindUniverse.DistinctConvertersUsed.Count() > 0) { #>
+        <#=Projection(DUI.NamespaceWindowsUIXaml)#>::ResourceDictionary localResources { nullptr };
+<#      if (!Model.CodeInfo.IsResourceDictionary) { #>
+        ::Microsoft::WRL::WeakRef converterLookupRoot; // <#=Projection(DUI.NamespaceWindowsUIXaml)#>::FrameworkElement
+<#      }#>
+<#  }#>
+<#  if (bindUniverse.HasBindings) { #>
+<#      if (bindUniverse.HasFunctionBindings) {#>
+<#          Output_TryGetValueFunctions(bindUniverse);#>
+<#          Output_FunctionBindings(bindUniverse);#>
+<#      }#>
+<#      if (bindUniverse.NeedsCompleteUpdate) { #>
+<#          Output_CompleteUpdate(bindUniverse);#>
+<#      }#>
+
+        // Update methods for each path node used in binding steps.
+<#  }#>
+<#  foreach (var bindStep in bindUniverse.BindPathSteps.Values.Where(bindStep => bindStep.IsIncludedInUpdate == true)) { #>
+
+<#      if (bindStep is FunctionStep) { #>
+        HRESULT Update_<#=bindStep.CodeName#>(INT32 phase)
+<#      } else { #>
+        HRESULT Update_<#=bindStep.CodeName#>(<#=bindStep.ValueType.WRLNameNonSmartVar()#> obj, INT32 phase)
+<#      }#>
+        {
+            HRESULT hr = S_OK;
+<#      Output_UpdateChildListeners_Call(bindStep, "obj");#>
+<#      Output_Update_Steps(bindStep.ValueType.IsNullable, bindStep.Children, true, "phase");#>
+<#      Output_Update_Steps(false, bindStep.Dependents, false, "phase");#>
+<#      foreach (int distinctPhase in bindStep.DistinctPhases) { #>
+<#          Output_Binding_Phased_SetValue(distinctPhase, true, bindStep, false);#>
+<#          Output_Binding_Phased_SetValue(distinctPhase, false, bindStep, false);#>
+<#      }#>
+<#      if (bindStep is RootStep) { #>
+<#          Output_Update_Steps(false, bindUniverse.BindPathSteps.Values.Where(s => s.Parent is StaticRootStep), false, "phase");#>
+<#          if (bindUniverse.NeedsCompleteUpdate) { #>
+            hr = CompleteUpdate(phase);
+            if (FAILED(hr)) return hr;
+<#          }#>
+<#      }#>
+
+            return hr;
+        }
+<#  }#>
+<#  foreach (var bindStep in bindUniverse.BindPathSteps.Values.Where(bindStep => bindStep.IsIncludedInUpdate == true)) { #>
+<#      if (bindStep.Parent != null && bindStep.BindStatus.HasFlag(BindStatus.HasFallbackValue)) { #>
+
+        HRESULT UpdateFallback_<#=bindStep.CodeName#>(int phase)
+        {
+            HRESULT hr = S_OK;
+
+<#          foreach (var childStep in bindStep.Children.Concat(bindStep.Dependents)) { #>
+<#              if (childStep.BindStatus.HasFlag(BindStatus.HasFallbackValue)) { #>
+            hr = UpdateFallback_<#=childStep.CodeName#>(phase);
+            if (FAILED(hr)) return hr;
+<#              } #>
+<#          }#>
+<#          foreach (int distinctPhase in bindStep.DistinctPhases)  { #>
+<#              Output_Binding_Phased_Fallback_SetValue(distinctPhase, true, bindStep);#>
+<#              Output_Binding_Phased_Fallback_SetValue(distinctPhase, false, bindStep);#>
+<#          } #>
+
+            return hr;
+        }
+<#      } #>
+<#  } #>
+<#  if (bindUniverse.NeedsBindingsTracking) { #>
+
+        HRESULT ReleaseAllListeners() override
+        {
+            HRESULT hr = S_OK;
+
+<#      foreach (var step in bindUniverse.BindPathSteps.Values.Where(step => step.NeedsUpdateChildListeners)) { #>
+<#          Output_UpdateChildListeners_Call(step, "nullptr");#>
+<#      }#>
+
+            return hr;
+        }
+
+        HRESULT PropertyChanged(IInspectable* sender, <#=Projection(DUI.NamespaceWindowsUIXamlData)#>::IPropertyChangedEventArgs* e) override
+        {
+            HRESULT hr = S_OK;
+
+<#      foreach (var step in bindUniverse.BindPathSteps.Values.Where(step => step.IsIncludedInUpdate == true)) { #>
+<#          if (step.RequiresChildNotification && step is PropertyStep or CastStep or RootStep or RootNamedElementStep or ArrayIndexStep or MapIndexStep && step.ImplementsINPC) { #>
+            {
+<#              if (step.RequiresChildNotification && step is not RootStep) { #>
+                ::Microsoft::WRL::ComPtr<::ABI::Windows::UI::Xaml::Data::INotifyPropertyChanged> spContainingNotify;
+                HRESULT hrGetNotify = <#="cachePC_" + step.CodeName#>.As(&spContainingNotify);
+<#              } else {#>
+                ::Microsoft::WRL::ComPtr<<#=bindUniverse.DataRootType.WRLNameInterface()#>> spContainingNotify;
+                HRESULT hrGetNotify = GetDataRoot(&spContainingNotify);
+<#              }#>
+                if (SUCCEEDED(hrGetNotify) && spContainingNotify.Get() && __XAML_IsSameObject(spContainingNotify.Get(), sender))
+                {
+                    ::Microsoft::WRL::Wrappers::HString propName;
+                    hr = e->get_PropertyName(propName.GetAddressOf());
+                    if (FAILED(hr)) return hr;
+
+                    <#=step.ValueType.WRLDeclareSmartVar("objT")#>
+                    sender->QueryInterface(IID_PPV_ARGS(&objT));
+                    <#=step.ValueType.WRLNameNonSmartVar()#> obj = <#=step.ValueType.WRLGetSmartVar("objT")#>;
+                    if (!propName.Get())
+                    {
+<#              PushIndent(Indent.ThreeTabs);#>
+<#              Output_Update_Steps(step.ValueType.IsNullable, step.TrackingSteps, false, "DATA_CHANGED");#>
+<#              PopIndent();#>
+                    }
+<#              foreach (string propertyName in step.TrackingSteps.OfType<PropertyStep>().Select(p => p.PropertyName).Distinct()) { #>
+                    else if (wcscmp(propName.GetRawBuffer(nullptr), L"<#=propertyName#>") == 0)
+                    {
+<#                  PushIndent(Indent.ThreeTabs); #>
+<#                  foreach (var child in step.TrackingSteps.OfType<PropertyStep>().Where(p => p.PropertyName == propertyName)) { #>
+<#                      Output_Update_DataChanged_Step(child); #>
+<#                  } #>
+<#                  PopIndent(); #>
+                    }
+<#              } #>
+<#              foreach (string functionName in step.TrackingSteps.OfType<FunctionStep>().Select(p => p.Method.MethodName).Distinct())#>
+<#              {#>
+                    else if (wcscmp(propName.GetRawBuffer(nullptr), L"<#=functionName#>") == 0)
+                    {
+<#                  PushIndent(Indent.ThreeTabs);#>
+<#                  Output_Update_Steps(step.ValueType.IsNullable, step.TrackingSteps.OfType<FunctionStep>().Where(p => p.Method.MethodName == functionName), false, "DATA_CHANGED");#>
+<#                  PopIndent();#>
+                    }
+<#              }#>
+                }
+            }
+<#          }#>
+<#      }#>
+<#      if (bindUniverse.NeedsCompleteUpdate) { #>
+
+            hr = CompleteUpdate(DATA_CHANGED);
+            if (FAILED(hr)) return hr;
+<#      }#>
+
+            return hr;
+        }
+
+        HRESULT CollectionChanged(IInspectable* sender, <#=Projection(DUI.NamespaceWindowsUIXamlInterop)#>::INotifyCollectionChangedEventArgs* e) override
+        {
+            HRESULT hr = S_OK;
+
+<#  foreach (var step in bindUniverse.BindPathSteps.Values.Where(step => step.IsIncludedInUpdate == true)) { #>
+<#      if (step.RequiresChildNotification && (step is not PropertyStep && step is not CastStep && step is not RootStep && step is not RootNamedElementStep) && step.ImplementsINCC && !step.ImplementsIObservableVector && !step.ImplementsIObservableMap) { #>
+            {
+<#          if (step.RequiresChildNotification && step is not RootStep) { #>
+                ::Microsoft::WRL::ComPtr<::ABI::Windows::UI::Xaml::Interop::INotifyCollectionChanged> spContainingNotify;
+                HRESULT hrGetNotify = <#="cacheCC_" + step.CodeName#>.As(&spContainingNotify);
+<#          } else {#>
+                ::Microsoft::WRL::ComPtr<<#=bindUniverse.DataRootType.WRLNameInterface()#>> spContainingNotify;
+                HRESULT hrGetNotify = GetDataRoot(&spContainingNotify);
+<#          }#>
+                if (SUCCEEDED(hrGetNotify) && spContainingNotify.Get() && __XAML_IsSameObject(spContainingNotify.Get(), sender))
+                {
+                    <#=step.ValueType.WRLDeclareSmartVar("objT")#>
+                    sender->QueryInterface(IID_PPV_ARGS(&objT));
+                    <#=step.ValueType.WRLNameNonSmartVar()#> obj = <#=step.ValueType.WRLGetSmartVar("objT")#>;
+<#          PushIndent();#>
+<#          Output_Update_Steps(step.ValueType.IsNullable, step.TrackingSteps, false, "DATA_CHANGED");#>
+<#          PopIndent();#>
+
+                    return hr;
+                }
+            }
+<#      }#>
+<#  }#>
+<#  if (bindUniverse.NeedsCompleteUpdate) { #>
+
+            hr = CompleteUpdate(DATA_CHANGED);
+            if (FAILED(hr)) return hr;
+<#  }#>
+
+            return hr;
+        }
+
+        HRESULT VectorChanged(IInspectable* sender, <#=Projection(DUI.NamespaceWindowsFoundationCollections)#>::IVectorChangedEventArgs* e) override
+        {
+            HRESULT hr = S_OK;
+
+<#      foreach (var step in bindUniverse.BindPathSteps.Values.Where(step => step.IsIncludedInUpdate == true)) { #>
+<#          if (step.RequiresChildNotification && step is PropertyStep or CastStep or RootStep && step.ImplementsIObservableVector) { #>
+            {
+<#              if (step.RequiresChildNotification && step is not RootStep) { #>
+                ::Microsoft::WRL::ComPtr<<#=step.ValueType.WRLNameInterface()#>> spContainingNotify;
+                HRESULT hrGetNotify = <#="cacheVC_" + step.CodeName#>.As(&spContainingNotify);
+<#              } else {#>
+                ::Microsoft::WRL::ComPtr<<#=bindUniverse.DataRootType.WRLNameInterface()#>> spContainingNotify;
+                HRESULT hrGetNotify = GetDataRoot(&spContainingNotify);
+<#              }#>
+                if (SUCCEEDED(hrGetNotify) && spContainingNotify.Get() && __XAML_IsSameObject(spContainingNotify.Get(), sender))
+                {
+                    <#=step.ValueType.WRLDeclareSmartVar("objT")#>
+                    sender->QueryInterface(IID_PPV_ARGS(&objT));
+                    <#=step.ValueType.WRLNameNonSmartVar()#> obj = <#=step.ValueType.WRLGetSmartVar("objT")#>;
+<#              PushIndent();#>
+<#              Output_Update_Steps(step.ValueType.IsNullable, step.TrackingSteps, false, "DATA_CHANGED");#>
+<#              PopIndent();#>
+
+                    return hr;
+                }
+            }
+<#          }#>
+<#      }#>
+<#      if (bindUniverse.NeedsCompleteUpdate) { #>
+
+            hr = CompleteUpdate(DATA_CHANGED);
+            if (FAILED(hr)) return hr;
+<#      }#>
+
+            return hr;
+        }
+
+        HRESULT MapChanged(IInspectable* sender, ::ABI::Windows::Foundation::Collections::IMapChangedEventArgs<HSTRING>* e) override
+        {
+            HRESULT hr = S_OK;
+
+<#      foreach (var step in bindUniverse.BindPathSteps.Values.Where(step => step.IsIncludedInUpdate == true)) { #>
+<#          if (step.RequiresChildNotification && step is PropertyStep or CastStep or RootStep && step.ImplementsIObservableMap) { #>
+            {
+<#              if (step.RequiresChildNotification && step is not RootStep) { #>
+                ::Microsoft::WRL::ComPtr<<#=step.ValueType.WRLNameInterface()#>> spContainingNotify;
+                HRESULT hrGetNotify = <#="cacheMC_" + step.CodeName#>.As(&spContainingNotify);
+<#              } else {#>
+                ::Microsoft::WRL::ComPtr<<#=bindUniverse.DataRootType.WRLNameInterface()#>> spContainingNotify;
+                HRESULT hrGetNotify = GetDataRoot(&spContainingNotify);
+<#              }#>
+                if (SUCCEEDED(hrGetNotify) && spContainingNotify.Get() && __XAML_IsSameObject(spContainingNotify.Get(), sender))
+                {
+                    <#=step.ValueType.WRLDeclareSmartVar("objT")#>
+                    sender->QueryInterface(IID_PPV_ARGS(&objT));
+                    <#=step.ValueType.WRLNameNonSmartVar()#> obj = <#=step.ValueType.WRLGetSmartVar("objT")#>;
+<#              PushIndent();#>
+<#              Output_Update_Steps(step.ValueType.IsNullable, step.TrackingSteps, false, "DATA_CHANGED");#>
+<#              PopIndent();#>
+                }
+            }
+<#          }#>
+<#      }#>
+<#      if (bindUniverse.NeedsCompleteUpdate) { #>
+
+            hr = CompleteUpdate(DATA_CHANGED);
+            if (FAILED(hr)) return hr;
+<#      }#>
+
+            return hr;
+        }
+
+        HRESULT DependencyPropertyChanged(IDependencyObject* sender, IDependencyProperty* prop) override
+        {
+            HRESULT hr = S_OK;
+
+            if (sender)
+            {
+<#      foreach (var step in bindUniverse.BindPathSteps.Values.Where(step => step.IsIncludedInUpdate == true)) { #>
+<#          foreach (var child in step.TrackingSteps.OfType<DependencyPropertyStep>()) { #>
+                if (sender == cacheDPC_<#=child.CodeName#><#= step is RootStep ? ".get()" : "" #> && <#=child.OwnerType.CppWinRTLocalElseRef()#>::<#=child.PropertyName#>Property() == prop)
+                {
+                    <#=step.ValueType.WRLDeclareSmartVar("objT")#>
+                    sender->QueryInterface(IID_PPV_ARGS(&objT));
+                    <#=step.ValueType.WRLNameNonSmartVar()#> obj = <#=step.ValueType.WRLGetSmartVar("objT")#>;
+<#              PushIndent(Indent.TwoTabs);#>
+<#              Output_Update_DataChanged_Step(child);#>
+<#              PopIndent();#>
+                }
+<#          }#>
+<#      }#>
+<#      if (bindUniverse.HasFunctionBindings) { #>
+                hr = CompleteUpdate(DATA_CHANGED);
+                if (FAILED(hr)) return hr;
+<#      }#>
+            }
+
+            return hr;
+        }
+
+<#  if (ProjectInfo.IsInputValidationEnabled) {#>
+        HRESULT ErrorsChanged(IInspectable* sender, <#=Projection(DUI.NamespaceWindowsUIXamlData)#>::IDataErrorsChangedEventArgs* e) override
+        {
+            HRESULT hr = S_OK;
+
+<#      foreach (var step in bindUniverse.INDEIPathSteps)#>
+<#      {#>
+<#          string cacheName = "GetDataRoot()";#>
+<#          if (!(step is RootStep))#>
+<#          {#>
+<#              cacheName="cacheEC_" + step.CodeName;#>
+<#          }#>
+            if (<#=cacheName#> != nullptr && <#=cacheName#> == sender)
+            {
+                auto errorInfo = sender.as<<#=Projection(DUI.NamespaceWindowsUIXamlData)#>::INotifyDataErrorInfo>();
+                auto propertyName = e.PropertyName();
+                if (propertyName.empty())
+                {
+<#          foreach (var child in step.TrackingSteps.OfType<PropertyStep>())#>
+<#          {#>
+<#               Output_UpdateErrorsCall(child);#>
+<#          }#>
+                }
+<#          foreach (string propertyName in step.TrackingSteps.OfType<PropertyStep>().Select(p => p.PropertyName).Distinct())#>
+<#          { #>
+                else if (propertyName == L"<#=propertyName#>")
+                {
+<#              foreach (var child in step.TrackingSteps.OfType<PropertyStep>().Where(p => p.PropertyName == propertyName)) #>
+<#              { #>
+<#              Output_UpdateErrorsCall(child);#>
+<#              } #>
+                }
+            }
+<#          }#>
+<#      }#>
+
+            return hr;
+        }
+<# void Output_UpdateErrorsCall(PropertyStep step) #>
+<# { #>
+<#      foreach (var ba in step.AssociatedBindAssignments.Where(ba => ba.IsTrackingTarget)) {#>
+                    UpdateErrors(<#=(ba as BindAssignmentBase).ConnectionIdElement.ObjectCodeName #>, errorInfo, L"<#= step.PropertyName #>");
+<#      }#>
+<#  }#>
+<# if (bindUniverse.INDEIPathSteps.Any()) { #>
+
+        void UpdateErrors(<#=Projection(DUI.NamespaceWindowsUIXamlControls)#>::Control const& control, <#=Projection(DUI.NamespaceWindowsUIXamlData)#>::INotifyDataErrorInfo const& sender, ::winrt::hstring propertyName)
+        {
+            if (auto validationControl = control.try_as<#=Projection(DUI.NamespaceWindowsUIXamlControls)#>::IInputValidationControl>())
+            {
+                auto validationErrors =  validationControl.ValidationErrors();
+                validationErrors.Clear();
+                for (const auto& error : sender.GetErrors(propertyName))
+                {
+                    auto inputValidationError = ::winrt::unbox_value<<#=Projection(DUI.NamespaceWindowsUIXamlControls)#>::InputValidationError>(error);
+                    if (inputValidationError == nullptr)
+                    {
+                        auto errorMessage = ::winrt::unbox_value<::winrt::hstring>(error);
+                        if (errorMessage.empty())
+                        {
+                            if (auto stringable = ::winrt::unbox_value<<#=Projection(DUI.NamespaceWindowsFoundation)#>::IStringable>(error))
+                            {
+                                errorMessage = stringable.ToString();
+                            }
+                            else
+                            {
+                                errorMessage = ::winrt::get_class_name(error);
+                            }
+                        }
+                        inputValidationError = <#=Projection(DUI.NamespaceWindowsUIXamlControls)#>::InputValidationError(errorMessage);
+                    }
+                    validationErrors.Append(inputValidationError);
+                }
+            }
+        }
+<# }#>
+<# } #>
+<#  } #>
+<# Output_BindingSetters(bindUniverse); #>
+    }; <# /* End of bindings class */ #>
+
+<#+ private void Output_ConnectionId_Case(ConnectionIdElement element)#>
+<#+ {#>
+                    // BEGIN Output_ConnectionId_Case(...)
+<#+     if (element.BindUniverse.BoundElements.Contains(element)) { #>
+<#+     Output_ApiInformationCall_Push(element.ApiInformation, Indent.ThreeTabs); #>
+<#+         if (element.IsWeakRef) { #>
+                    hr = ::Microsoft::WRL::AsWeak(target, &<#=element.ObjectCodeName#>);
+<#+         } else { #>
+                    hr = target->QueryInterface(IID_PPV_ARGS(&<#=element.ObjectCodeName#>));
+<#+         } #>
+                    if (FAILED(hr)) return hr;
+
+<#+     foreach (BoundEventAssignment evt in element.BoundEventAssignments) { #>
+<#+         Output_ApiInformationCall_Push(evt.ApiInformation, Indent.ThreeTabs); #>
+                    {
+                        HRESULT hrT = hr;
+<#+         PushIndent(Indent.SixTabs);#>
+<#=element.Type.WRLDeclareQIIfNeeded(
+    element.Type.WRLNameInterfaceSpecific("add_" + evt.MemberName),
+    element.IsWeakRef ? "target" : element.ObjectCodeName, "pTemp", forceQI: element.IsWeakRef)#>
+<#+         PopIndent();#>
+                        hr = hrT;
+                        if (FAILED(hr)) return hr;
+
+                        auto spCallback = ::Microsoft::WRL::Callback<<#=evt.MemberType.WRLNameInterface()#>>([this](<#=evt.Parameters.Declaration()#>) -> HRESULT
+                        {
+                            HRESULT hrInner = S_OK;
+
+<#+         if (!evt.PathStep.ValueType.IsDelegate()) { #>
+                            HRESULT hrT = hrInner;
+                            // Paste evt.PathStep.CodeGen().PathExpression (of type <#=evt.PathStep.CodeGen().GetType().FullName#>)
+<#+             PushIndent(Indent.SevenTabs);#>
+<#=evt.PathStep.CodeGen().PathExpression#>;
+<#+             PopIndent();#>
+                            hrInner = hrT;
+<#+         } else { #>
+                            HowToHandleThisPleaseTell<#="aaaaaa"/*evt.PathStep.CodeGen().PathExpression*/#>(<#="aaaaaa"/*evt.Parameters.ForCall()*/#>); // TODO IS THIS INVOKING AN EVENT SOURCE?
+<#+         }#>
+
+                            return hrInner;
+                        });
+                        if (spCallback.Get())
+                        {
+                            ::EventRegistrationToken tokenIgnored;
+                            hr = pTemp->add_<#=evt.MemberName#>(spCallback.Get(), &tokenIgnored);
+                        }
+                        else
+                        {
+                            hr = E_OUTOFMEMORY;
+                        }
+                        if (FAILED(hr)) return hr;
+                    }
+<#+         Output_ApiInformationCall_Pop(evt.ApiInformation, Indent.ThreeTabs); #>
+<#+     }#>
+<#+     if (element.CanBeInstantiatedLater && (element.HasBindAssignments || element.HasBoundEventAssignments))#>
+<#+     {#>
+<#+         /* In Connect() we update non-load assignments first, */ #>
+<#+         foreach (var ba in element.BindAssignments.Where(ba => !(ba is BoundLoadAssignment))) #>
+<#+         { #>
+<#+             PushIndent(Indent.TwoTabs); #>
+<#+             Output_Binding_SetValue_Non_Function_Call(ba, ba.ObjectDeferredAssignmentCodeName, false); #>
+<#+             PopIndent(); #>
+<#+         } #>
+<#+     }#>
+<#+     foreach (var ba in element.BindAssignments.Where(bindAssignment => bindAssignment.IsTrackingTarget)) { #>
+<#+         PushIndent();#>
+<#+         Output_Connect_TwoWayBinding(ba);#>
+<#+         PopIndent();#>
+<#+     }#>
+<#+     Output_ApiInformationCall_Pop(element.ApiInformation, Indent.ThreeTabs); #>
+<#+     } #>
+<#+     if (!element.IsBindingRoot) #>
+<#+     { #>
+<#+         /* Queue load assignments to be updated later, because they're not available yet. */ #>
+<#+         foreach (var childElem in element.Children.Intersect(element.BindUniverse.ElementsWithBoundLoadAssignments)) #>
+<#+         { #>
+                    size_t iElem;
+                    if (FAILED(UnloadedElementsToUpdate.Find(<#=childElem.ConnectionId#>, &iElem)))
+                    {
+                        hr = UnloadedElementsToUpdate.Add(<#=childElem.ConnectionId#>);
+                        if (FAILED(hr)) return hr;
+                    }
+<#+         } #>
+<#+     } #>
+<#+     if (element.CanBeInstantiatedLater && element.HasRootNamedElementStep) { #>
+                    static_assert(false, "This scenario has not been tested yet.");
+                    this->UnloadableBindingSourcesToUpdate.push_back([this]()
+                    {
+<#+         PushIndent(Indent.TwoTabs); #>
+<#+         Output_Custom_Update_Call(element.RootNamedElementStep, element.RootNamedElementStep.CodeGen().PathExpression.WRLName(), "TODO", KnownStrings.NotPhased);#>
+<#+         PopIndent(); #>
+                    });
+<#+     } #>
+<#+    if (element.TryGetValidationContextStep(out PropertyStep validationStep) && ProjectInfo.IsInputValidationEnabled && ProjectInfo.EnableDefaultValidationContextGeneration) #>
+<#+    { #>
+<#+        Output_ApiInformationCall_Push(validationStep.ApiInformation, Indent.ThreeTabs); #>
+                    <#=Projection(DUI.NamespaceWindowsUIXamlControls)#>::InputValidationContext context(L"<#=validationStep.PropertyName #>", <#=validationStep.IsValueRequired#>);
+                    target.as<<#=Projection(DUI.NamespaceWindowsUIXamlControls)#>::IInputValidationControl>().ValidationContext(context);
+<#+        Output_ApiInformationCall_Pop(validationStep.ApiInformation, Indent.ThreeTabs); #>
+<#+    }#>
+                    // END Output_ConnectionId_Case(...)
+<#+  }#>
+
+<#+     private void Output_Listener_Tracking_Fields(BindUniverse bindUniverse)#>
+<#+     {#>
+        // BEGIN Output_Listener_Tracking_Fields
+<#+         foreach(var cache in GetCacheDeclarations(bindUniverse)) { #>
+        <#= cache #>
+<#+         }#>
+<#+         foreach(var token in GetTokenDeclarations(bindUniverse)) { #>
+        <#= token #>
+<#+         }#>
+        // END Output_Listener_Tracking_Fields
+<#+     }#>
+
+<#+ private void Output_Connect_TwoWayBinding(BindAssignment ba)#>
+<#+ {#>
+                // BEGIN Output_Connect_TwoWayBinding(<#=ba.CodeName#>)
+<#+     Output_ApiInformationCall_Push(ba.ApiInformation, Indent.None); #>
+                HRESULT hrT = hr;
+<#+     PushIndent(Indent.FourTabs);#>
+<#=ba.ConnectionIdElement.ReferenceExpression#>
+<#+     PopIndent();#>
+                hr = hrT;
+                if (FAILED(hr)) return hr;
+
+<#+     if (ba.NeedsLostFocusForTwoWay) { #>
+                hrT = hr;
+<#+     PushIndent(Indent.FourTabs);#>
+<#=ba.ConnectionIdElement.Type.WRLDeclareQIIfNeeded($"{Projection(DUI.NamespaceWindowsUIXaml)}::IUIElement", "_ConnectionIdElement_Reference", "pUIElement")#>
+<#+     PopIndent();#>
+                hr = hrT;
+                if (FAILED(hr)) return hr;
+
+                ::EventRegistrationToken tokenIgnored;
+                hr = pUIElement->add_LostFocus(
+                    Callback<::ABI::Windows::UI::Xaml::IRoutedEventHandler>([this](IInspectable* sender, <#=Projection(DUI.NamespaceWindowsUIXaml)#>::IRoutedEventArgs* prop)
+                    {
+<#+     } else { #>
+                ::Microsoft::WRL::ComPtr<ABI::Windows::UI::Xaml::IDependencyObject2> dependencyObject2;
+                hr = _ConnectionIdElement_Reference->QueryInterface(IID_PPV_ARGS(&dependencyObject2));
+                if (FAILED(hr)) return hr;
+
+<#+         if (DomHelper.IsLocalType(ba.MemberDeclaringType)) { #>
+                ::Microsoft::WRL::ComPtr<IDependencyProperty> dependencyProperty;
+                hr = <#=ba.MemberDeclaringType.WRLName()#>::get_<#=ba.MemberName#>Property(&dependencyProperty);
+                if (FAILED(hr)) return hr;
+<#+         } else { #>
+                ::Microsoft::WRL::ComPtr<<#=ba.MemberDeclaringType.WRLNameInterface()#>Statics> memberDeclaringStatics;
+                hr = ::ABI::Windows::Foundation::GetActivationFactory(
+                    ::Microsoft::WRL::Wrappers::HStringReference(<#=ba.MemberDeclaringType.ToRuntimeClassNameConstant()#>).Get(),
+                    &memberDeclaringStatics);
+                if (FAILED(hr)) return hr;
+
+                ::Microsoft::WRL::ComPtr<IDependencyProperty> dependencyProperty;
+                hr = memberDeclaringStatics->get_<#=ba.MemberName#>Property(&dependencyProperty);
+                if (FAILED(hr)) return hr;
+<#+         } #>
+
+                ::EventRegistrationToken tokenIgnored;
+                hr = dependencyObject2->RegisterPropertyChangedCallback(dependencyProperty.Get(),
+                    Callback<::ABI::Windows::UI::Xaml::IDependencyPropertyChangedCallback>([this](IDependencyObject* sender, IDependencyProperty* prop)
+                    {
+<#+     } #>
+                        HRESULT hr = S_OK;
+
+                        if (IsInitialized())
+                        {
+                            // Update Two Way binding
+<#+     MethodStep bindBackStep = ba.BindBackStep as MethodStep; #>
+<#+     if (bindBackStep != null) { #>
+<#+         var param = bindBackStep.Parameters[0]; #>
+                            <#=ba.MemberType.WRLName()#> <#=param.Name#> = <#=ba.ReverseAssignmentExpression#>;
+<#+                         Output_NullCheckedAssignment(bindBackStep, null);#>
+<#+     } else { #>
+<#+                         Output_NullCheckedAssignment(ba.PathStep, ba.ReverseAssignmentExpression);#>
+<#+     }#>
+                        }
+
+                        return hr;
+                    }).Get(), &tokenIgnored);
+                if (FAILED(hr)) return hr;
+<#+     Output_ApiInformationCall_Pop(ba.ApiInformation, Indent.None); #>
+                // END Output_Connect_TwoWayBinding(<#=ba.CodeName#>)
+<#+ } #>
+
+<#+ void  Output_NullCheckedAssignment(BindPathStep step, LanguageSpecificString value) #>
+<#+ { #>
+<#+     PushIndent(Indent.FourTabs);#>
+            // BEGIN Output_NullCheckedAssignment(<#=step.CodeName#>, ...)
+<#+     foreach (var parent in step.Parents.Where(parent => parent.NeedsCheckForNull)) { #>
+            HRESULT hrT = hr;
+            // [debug] codegen type is <#=parent.CodeGen().GetType().Name#>
+
+<#+         PushIndent(Indent.ThreeTabs);#>
+<#=parent.CodeGen().PathExpression#>
+<#+         PopIndent();#>
+            if (SUCCEEDED(hrT) && <#=parent.CodeGen().PathExpression.WRLOutVarName()#>)
+            {
+<#+         PushIndent(); #>
+<#+     } #>
+<#+     if (value != null) { #>
+<#+         PushIndent(Indent.ThreeTabs); #>
+<#=step.CodeGen().PathSetExpression(value)#>
+<#+         PopIndent(); #>
+            hr = hrT;
+<#+     } else { #>
+            HowToHandleThis<#="aaaa"/*step.CodeGen().PathExpression*/#>;
+<#+     } #>
+<#+     foreach (var parent in step.Parents.Where(parent => parent.NeedsCheckForNull)) { #>
+<#+         PopIndent(); #>
+            }
+<#+     } #>
+            // END Output_NullCheckedAssignment(<#=step.CodeName#>, ...)
+<#+     PopIndent();#>
+<#+ } #>
+
+<#+     private void Output_UpdateChildListeners_Call(BindPathStep step, string parameter)#>
+<#+     {#>
+            // BEGIN Output_UpdateChildListeners_Call(<#=step.CodeName#>, <#=parameter#>)
+<#+         if (step.NeedsUpdateChildListeners)#>
+<#+         {#>
+<#+             var hasParameter = parameter != "nullptr"; #>
+<#+             var failedCheckStatement = hasParameter ? "if (FAILED(hr)) return hr;" : "hr = S_OK;"; #>
+<#+             Output_ApiInformationCall_Push(step.ApiInformation, Indent.OneTab); #>
+<#+             if (step.ImplementsINPC) { #>
+            {
+<#+                 if (hasParameter) { #>
+                HRESULT hrT = hr;
+<#+                 PushIndent(Indent.FourTabs);#>
+<#=step.ValueType.WRLDeclareQIIfNeeded(Projection(DUI.NamespaceWindowsUIXamlData) + "::INotifyPropertyChanged", parameter, "pnpc")#>
+<#+                 PopIndent();#>
+                hr = hrT;
+                if (FAILED(hr)) return hr;
+<#+                 } else { #>
+                <#=Projection(DUI.NamespaceWindowsUIXamlData)#>::INotifyPropertyChanged* pnpc = nullptr;
+<#+                 } #>
+
+                hr = _bindingsTracking->UpdatePropertyChangedListener(pnpc, cachePC_<#=step.CodeName#>, tokenPC_<#=step.CodeName#>);
+                <#=failedCheckStatement#>
+            }
+<#+             }#>
+<#+             if (step.ImplementsINDEI && ProjectInfo.IsInputValidationEnabled) { #>
+            {
+<#+                 if (hasParameter) { #>
+                HRESULT hrT = hr;
+<#+                 PushIndent(Indent.FourTabs);#>
+<#=step.ValueType.WRLDeclareQIIfNeeded(Projection(DUI.NamespaceWindowsUIXamlData) + "::INotifyDataErrorInfo", parameter, "pndei")#>
+<#+                 PopIndent();#>
+                hr = hrT;
+                if (FAILED(hr)) return hr;
+<#+                 } else { #>
+                <#=Projection(DUI.NamespaceWindowsUIXamlData)#>::INotifyDataErrorInfo* pndei = nullptr;
+<#+                 } #>
+
+                hr = _bindingsTracking->UpdateErrorsChangedListener(pndei, cacheEC_<#=step.CodeName#>, tokenEC_<#=step.CodeName#>);
+                <#=failedCheckStatement#>
+            }
+<#+             }#>
+<#+             if (step.ImplementsIObservableVector) { #>
+            {
+                hr = _bindingsTracking->UpdateVectorChangedListener_<#=step.ValueType.ItemType.MemberFriendlyName()#>(<#=parameter#>, cacheVC_<#=step.CodeName#>, tokenVC_<#=step.CodeName#>);
+                <#=failedCheckStatement#>
+            }
+<#+             }#>
+<#+             if (step.ImplementsIObservableMap) { #>
+            {
+                hr = _bindingsTracking->UpdateMapChangedListener_<#=step.ValueType.ItemType.MemberFriendlyName()#>(<#=parameter#>, cacheMC_<#=step.CodeName#>, tokenMC_<#=step.CodeName#>);
+                <#=failedCheckStatement#>
+            }
+<#+             }#>
+<#+             else if (step.ImplementsINCC) { #>
+            {
+<#+                 if (hasParameter) { #>
+                HRESULT hrT = hr;
+<#+                 PushIndent(Indent.FourTabs);#>
+<#=step.ValueType.WRLDeclareQIIfNeeded(Projection(DUI.NamespaceWindowsUIXamlInterop) + "::INotifyCollectionChanged", parameter, "pincc")#>
+<#+                 PopIndent();#>
+                hr = hrT;
+                if (FAILED(hr)) return hr;
+<#+                 } else { #>
+                <#=Projection(DUI.NamespaceWindowsUIXamlInterop)#>::INotifyCollectionChanged* pincc = nullptr;
+<#+                 } #>
+
+                hr = _bindingsTracking->UpdateCollectionChangedListener(pincc, cacheCC_<#=step.CodeName#>, tokenCC_<#=step.CodeName#>);
+                <#=failedCheckStatement#>
+            }
+<#+             }#>
+<#+             foreach (var child in step.TrackingSteps.OfType<DependencyPropertyStep>()) { #>
+            {
+<#+                 if (DomHelper.IsLocalType(child.OwnerType)) { #>
+                ::Microsoft::WRL::ComPtr<IDependencyProperty> dependencyProperty;
+                hr = <#=child.OwnerType.WRLName()#>::get_<#=child.PropertyName#>Property(&dependencyProperty);
+                if (FAILED(hr)) return hr;
+<#+                 } else { #>
+                ::Microsoft::WRL::ComPtr<<#=child.OwnerType.WRLNameStaticInterfaceSpecific($"get_{child.PropertyName}Property")#>> memberDeclaringStatics;
+                hr = ::ABI::Windows::Foundation::GetActivationFactory(
+                    ::Microsoft::WRL::Wrappers::HStringReference(<#=child.OwnerType.ToRuntimeClassNameConstant()#>).Get(),
+                    &memberDeclaringStatics);
+                if (FAILED(hr)) return hr;
+
+                ::Microsoft::WRL::ComPtr<IDependencyProperty> dependencyProperty;
+                hr = memberDeclaringStatics->get_<#=child.PropertyName#>Property(&dependencyProperty);
+                if (FAILED(hr)) return hr;
+<#+                 } #>
+
+                hr = _bindingsTracking->UpdateDependencyPropertyChangedListener(<#=parameter#>, dependencyProperty.Get(), cacheDPC_<#=child.CodeName#>, tokenDPC_<#=child.CodeName#>);
+                <#=failedCheckStatement#>
+            }
+<#+             }#>
+<#+             Output_ApiInformationCall_Pop(step.ApiInformation, Indent.OneTab); #>
+<#+         }#>
+            // END Output_UpdateChildListeners_Call(<#=step.CodeName#>, <#=parameter#>)
+<#+     }#>
+
+<#+ private void Output_Binding_Phased_SetValue(int phase, bool isTracking, BindPathStep bindStep, bool isFunctionResult)#>
+<#+ {#>
+            // BEGIN Output_Binding_Phased_SetValue(<#=phase#>, <#=isTracking#>, <#=bindStep.CodeName#>, <#=isFunctionResult#>)
+<#+     var matchingBindAssignments = from ba in bindStep.BindAssignments where ba.ComputedPhase == phase && ba.IsTrackingSource == isTracking select ba;#>
+<#+     if (matchingBindAssignments.Count() > 0)#>
+<#+     {#>
+<#+         string condition =  GetDirectPhaseCondition(phase, isTracking); #>
+            if(<#=condition#>)
+            {
+<#+         PushIndent();#>
+<#+         foreach (BindAssignment bindAssignment in matchingBindAssignments)#>
+<#+         {#>
+<#+             Output_Binding_SetValue(bindAssignment, bindStep, isFunctionResult);#>
+<#+         }#>
+<#+         PopIndent();#>
+            }
+<#+     }#>
+            // END Output_Binding_Phased_SetValue(<#=phase#>, <#=isTracking#>, <#=bindStep.CodeName#>, <#=isFunctionResult#>)
+<#+ }#>
+
+<#+ private void Output_Binding_Phased_Fallback_SetValue(int phase, bool isTracking, BindPathStep bindStep)#>
+<#+ {#>
+            // BEGIN Output_Binding_Phased_Fallback_SetValue(<#=phase#>, <#=isTracking#>, <#=bindStep.CodeName#>)
+<#+     var matchingBindAssignments = from ba in bindStep.BindAssignments where ba.ComputedPhase == phase && ba.IsTrackingSource == isTracking && ba.BindStatus.HasFlag(BindStatus.HasFallbackValue) select ba;#>
+<#+     if (matchingBindAssignments.Count() > 0)#>
+<#+     {#>
+<#+         string condition =  GetDirectPhaseCondition(phase, isTracking); #>
+            if (<#=condition#>)
+            {
+<#+         PushIndent();#>
+<#+         foreach (BindAssignment bindAssignment in matchingBindAssignments)#>
+<#+         {#>
+<#+             Output_Binding_SetValue_Non_Function_Call(bindAssignment, bindAssignment.FallbackValueExpression, true);#>
+<#+         }#>
+<#+         PopIndent();#>
+            }
+<#+     }#>
+            // END Output_Binding_Phased_Fallback_SetValue(<#=phase#>, <#=isTracking#>, <#=bindStep.CodeName#>)
+<#+ }#>
+
+<#+ private void Output_Binding_SetValue(BindAssignment bindAssignment, BindPathStep bindStep, bool isFunctionResult)#>
+<#+ {#>
+            // BEGIN Output_Binding_SetValue(<#=bindAssignment.CodeName#>, <#=isFunctionResult#>)
+<#+         if (bindAssignment.PathStep is FunctionStep && !isFunctionResult)#>
+<#+         {#>
+            hr = PendingFunctionBindings.AddItem(L"<#=bindAssignment.PathStep.CodeName#>", &<#=bindAssignment.BindUniverse.BindingsClassName#>::Invoke_<#=bindAssignment.PathStep.CodeName#>);
+<#+         }#>
+<#+         else#>
+<#+         {#>
+<#+             LanguageSpecificString value = bindAssignment.DirectAssignmentExpression(isFunctionResult ? (bindStep is FunctionStep fs ? fs.Method : bindStep).CodeGen().PathExpression.WRLOutVarName() : "obj");#>
+<#+             Output_Binding_SetValue_Non_Function_Call(bindAssignment, value, true);#>
+<#+         }#>
+            // END Output_Binding_SetValue(<#=bindAssignment.CodeName#>, <#=isFunctionResult#>)
+<#+     }#>
+
+<#+ private void Output_Binding_SetValue_Non_Function_Call(BindAssignment ba, ICodeGenOutput value, bool includeDeferredSet)#>
+<#+ {#>
+            // BEGIN Output_Binding_SetValue_Non_Function_Call(<#=ba.CodeName#>, ..., <#=includeDeferredSet#>)
+<#+     var element = ba.ConnectionIdElement;#>
+            // <#=element.LineNumberAndXamlFile#>
+            {
+<#+         PushIndent(); #>
+<#+     Output_ApiInformationCall_Push(ba.ApiInformation, Indent.OneTab); #>
+<#+     if (ba is BoundLoadAssignment) { #>
+            static_assert(false, "This scenario has not been tested yet.");
+<#+         if (includeDeferredSet) { #>
+            <#=ba.ObjectDeferredAssignmentCodeName#> = <#=value.WRLName()#>;
+
+<#+         }#>
+            if (<#=value.WRLName()#>)
+            {
+<#+         if (ba.BindUniverse.IsFileRoot) { #>
+                GetDataRoot().FindName(L"<#=element.ElementName#>");
+<#+         } else { #>
+                <#=ba.BindUniverse.RootElement.ReferenceExpression#>.FindName(L"<#=element.ElementName#>");
+<#+         }#>
+            }
+            else
+            {
+<#+         if (ba.BindUniverse.IsFileRoot) { #>
+                ::winrt::get_self<<#=ba.BindUniverse.DataRootType.CppWinRTLocalElseRef()#>>(GetDataRoot())->UnloadObject(<#=element.ReferenceExpression#>);
+<#+         } else { #>
+                if (<#=element.ReferenceExpression#>) 
+                {
+                    <#=Projection(DUI.NamespaceWindowsUIXamlMarkup)#>::XamlMarkupHelper::UnloadObject(<#=element.ReferenceExpression#>);
+                }
+                DisconnectUnloadedObject(<#=element.ConnectionId#>);
+<#+         }#>
+            }
+<#+     } else { #>
+<#+         if (element.NeedsNullCheckBeforeSetValue) {#>
+            if (<#=element.ObjectCodeName#>.Get())
+            {
+<#+             PushIndent();#>
+<#+         }#>
+            HRESULT hrT;
+
+<#+         if (ba.NeedsBox) {#>
+            ::Microsoft::WRL::ComPtr<::IInspectable> spBoxed;
+            hr = TroleBoxer::BoxValue(<#=value.WRLName()#>, &spBoxed);
+            if (FAILED(hr)) return hr;
+
+            ::IInspectable* potentiallyBoxedValue = spBoxed.Get();
+<#+         } else {#>
+            hrT = hr;
+<#+         PushIndent(Indent.ThreeTabs);#>
+<#=value.WRLName()#>
+<#+         PopIndent();#>
+            hr = hrT;
+            if (FAILED(hr)) return hr;
+
+            <#=ba.MemberType.WRLNameNonSmartVar()#> potentiallyBoxedValue = <#=value.WRLOutVarName()#>;
+<#+         }#>
+
+            hrT = hr;
+<#+         PushIndent(Indent.ThreeTabs);#>
+<#=element.ReferenceExpression#>
+<#+         PopIndent();#>
+            hr = hrT;
+            if (FAILED(hr)) return hr;
+
+            hrT = hr;
+<#+         PushIndent(Indent.ThreeTabs);#>
+<#=element.Type.WRLDeclareQIIfNeeded(ba.MemberTargetType.WRLNameInterface(), "_ConnectionIdElement_Reference", "_ConnectionIdElement_ReferenceP")#>
+<#+         PopIndent();#>
+            hr = hrT;
+            if (FAILED(hr)) return hr;
+
+<#+         if (ba.MemberType.IsNullable) { #>
+            hr = Set_<#=ba.MemberDeclaringType.MemberFriendlyName()#>_<#=ba.MemberName#>(_ConnectionIdElement_ReferenceP, potentiallyBoxedValue, <#=ba.TargetNullValueExpression#>);
+<#+         } else {#>
+            hr = Set_<#=ba.MemberDeclaringType.MemberFriendlyName()#>_<#=ba.MemberName#>(_ConnectionIdElement_ReferenceP, potentiallyBoxedValue);
+<#+         }#>
+            if (FAILED(hr)) return hr;
+<#+         if (element.NeedsNullCheckBeforeSetValue) {#>
+<#+             PopIndent();#>
+            }
+<#+             if (includeDeferredSet && element.CanBeInstantiatedLater) { #>
+            else
+            {
+                static_assert(false, "This scenario has not been tested yet.");
+                <#=ba.ObjectDeferredAssignmentCodeName#> = <#=value.WRLName()#>;
+            }
+<#+             }#>
+<#+         }#>
+<#+     }#>
+<#+     Output_ApiInformationCall_Pop(ba.ApiInformation, Indent.OneTab); #>
+<#+     PopIndent(); #>
+            }
+            // END Output_Binding_SetValue_Non_Function_Call(<#=ba.CodeName#>, ..., <#=includeDeferredSet#>)
+<#+ }#>
+
+<#+ private void Output_Update_DataChanged_Step( BindPathStep step)#>
+<#+ {#>
+            // BEGIN Output_Update_DataChanged_Step(<#=step.CodeName#>)
+<#+     if (step.Parent.ValueType.IsNullable) #>
+<#+     {#>
+            if (obj)
+            {
+<#+     }#>
+<#+     Output_UpdateCall(step, KnownStrings.DataChanged); #>
+<#+     if (step.Parent.ValueType.IsNullable) #>
+<#+     {#>
+            }
+<#+     }#>
+<#+     if (step.BindStatus.HasFlag(BindStatus.HasFallbackValue)) #>
+<#+     {#>
+            else
+            {
+                hr = UpdateFallback_<#=step.CodeName#>(DATA_CHANGED);
+                if (FAILED(hr)) return hr;
+            }
+<#+     }#>
+            // END Output_Update_DataChanged_Step(<#=step.CodeName#>)
+<#+ }#>
+
+<#+ private void Output_Update_Steps(bool checkForNull, IEnumerable<BindPathStep> steps, bool checkPhaseCondition, string phaseParam)#>
+<#+ {#>
+            // BEGIN Output_Update_Steps(<#=checkForNull#>, <#=steps.Count()#>, <#=checkPhaseCondition#>, <#=phaseParam#>)
+<#+     if (steps.Count() > 0) #>
+<#+     {#>
+<#+         if (checkForNull) #>
+<#+         {#>
+            if (obj)
+            {
+<#+         }#>
+<#+         List<BindPathStep> stepsWithFallback = new List<BindPathStep>();#>
+<#+         string lastCondition = null;#>
+<#+         foreach (var childStep in (from step in steps where step.IsIncludedInUpdate orderby step.PhaseList select step))#>
+<#+         {#>
+<#+             if(checkPhaseCondition) #>
+<#+             { #>
+<#+                 string thisCondition = GetPhaseCondition(childStep);#>
+<#+                 if (thisCondition != lastCondition)#>
+<#+                 {#>
+<#+                     if (lastCondition != null)#>
+<#+                     {#>
+                }
+<#+                     }#>
+<#+                     lastCondition = thisCondition;#>
+                if (<#=thisCondition#>)
+                {
+<#+                 }#>
+                    {
+<#+                 PushIndent(Indent.TwoTabs);#>
+<#+                 Output_UpdateCall(childStep, phaseParam); #>
+<#+                 PopIndent();#>
+                    }
+<#+             }#>
+<#+             else#>
+<#+             {#>
+<#+                 if (lastCondition != null)#>
+<#+                 {#>
+                }
+<#+                 }#>
+<#+                 lastCondition = null;#>
+                {
+<#+                 PushIndent();#>
+<#+                 Output_UpdateCall(childStep, phaseParam); #>
+<#+                 PopIndent();#>
+                }
+<#+             } #>
+<#+             if (childStep.BindStatus.HasFlag(BindStatus.HasFallbackValue)) #>
+<#+             {#>
+<#+               stepsWithFallback.Add(childStep);#>
+<#+             }#>
+<#+         }#>
+<#+                 if (lastCondition != null)#>
+<#+                 {#>
+                }
+<#+                 }#>
+<#+         if (checkForNull) #>
+<#+         {#>
+            }
+<#+             if (stepsWithFallback.Count > 0) #>
+<#+             {#>
+            else
+            {
+<#+                 foreach (var childStep in stepsWithFallback)#>
+<#+                 {#>
+<#+                     if(checkPhaseCondition) #>
+<#+                     { #>
+                if (<#=GetPhaseCondition(childStep)#>)
+                {
+                    hr = UpdateFallback_<#=childStep.CodeName#>(<#=phaseParam#>);
+                    if (FAILED(hr)) return hr;
+                }
+<#+                     } #>
+<#+                     else #>
+<#+                     { #>
+                hr = UpdateFallback_<#=childStep.CodeName#>(<#=phaseParam#>);
+                if (FAILED(hr)) return hr;
+<#+                     } #>
+<#+                 }#>
+            }
+<#+             }#>
+<#+         }#>
+<#+     }#>
+            // END Output_Update_Steps(<#=checkForNull#>, <#=steps.Count()#>, <#=checkPhaseCondition#>, <#=phaseParam#>)
+<#+ }#>
+
+<#+ private void Output_Custom_Update_Call(BindPathStep step, string firstArgumentInit, string firstArgumentName, string phaseParam)#>
+<#+ {#>
+                // BEGIN Output_Custom_Update_Call(<#=step.CodeName#>, ..., <#=firstArgumentName#>, <#=phaseParam#>)
+                // [debug] codegen type is <#=step.CodeGen().GetType().Name#>
+<#+     if (string.IsNullOrEmpty(firstArgumentInit)) { #>
+                hr = Update_<#=step.CodeName#>(<#=phaseParam#>);
+                if (FAILED(hr)) return hr;
+<#+     } else { #>
+<#+         Output_ApiInformationCall_Push(step.ApiInformation, Indent.TwoTabs);#>
+<#+         if (firstArgumentInit != "nullptr") { #>
+                HRESULT hrT = hr;
+<#+             PushIndent(Indent.FourTabs);#>
+<#=firstArgumentInit#>
+<#+             PopIndent();#>
+                hr = hrT;
+                if (FAILED(hr)) return hr;
+<#+         } #>
+
+                hr = Update_<#=step.CodeName#>(<#=firstArgumentName#>, <#=phaseParam#>);
+                if (FAILED(hr)) return hr;
+<#+         Output_ApiInformationCall_Pop(step.ApiInformation, Indent.TwoTabs);#>
+                // END Output_Custom_Update_Call(<#=step.CodeName#>, ..., <#=firstArgumentName#>, <#=phaseParam#>)
+<#+     }#>
+<#+ }#>
+
+<#+ private void Output_UpdateCall(BindPathStep step, string phaseParam)#>
+<#+ {#>
+                // BEGIN Output_UpdateCall(<#=step.CodeName#>, <#=phaseParam#>)
+<#+     string firstArgumentInit = step.CodeGen().UpdateCallParam.WRLName(); #>
+<#+     Output_Custom_Update_Call(step, firstArgumentInit, step.CodeGen().UpdateCallParam.WRLOutVarName(), phaseParam); #>
+                // END Output_UpdateCall(<#=step.CodeName#>, <#=phaseParam#>)
+<#+ }#>
+
+<#+ private void Output_CompleteUpdate(BindUniverse bindUniverse)#>
+<#+ {#>
+        // BEGIN Output_CompleteUpdate()
+<#+     List<string> conditions = new List<string>();#>
+<#+     bool needsLoop = bindUniverse.UnloadableBindingSourceElements.Any(); #>
+
+        HRESULT CompleteUpdate(int phase)
+        {
+            HRESULT hr = S_OK;
+
+<#+     if (needsLoop) { #>
+            do
+            {
+<#+         PushIndent(); #>
+<#+     } #>
+<#+     if (bindUniverse.HasFunctionBindings) { #>
+            auto copiedBindings = std::move(PendingFunctionBindings);
+            // PendingFunctionBindings = std::map<::std::wstring, std::function<void (int)>>();
+
+            copiedBindings.Enum([&](const wchar_t* key, HRESULT (<#=bindUniverse.BindingsClassName#>::*func)(int)) -> BOOL
+            {
+                hr = (this->*func)(phase);
+                return SUCCEEDED(hr);
+            });
+            if (FAILED(hr)) return hr;
+
+<#+         conditions.Add("this->PendingFunctionBindings.GetItemCount() != 0"); #>
+<#+     } #>
+<#+     if (bindUniverse.UnloadableBindingSourceElements.Any()) {#>
+            while (this->UnloadableBindingSourcesToUpdate.GetSize() != 0)
+            {
+                auto pmf = this->UnloadableBindingSourcesToUpdate[0];
+                hr = (this->*pmf)();
+                if (FAILED(hr)) return hr;
+
+                hr = this->UnloadableBindingSourcesToUpdate.RemoveAt(0);
+                if (FAILED(hr)) return hr;
+            }
+
+<#+         conditions.Add("this->UnloadableBindingSourcesToUpdate.GetSize() != 0"); #>
+<#+     } #>
+<#+     if (bindUniverse.ElementsWithBoundLoadAssignments.Any()) { #>
+            while (this->UnloadedElementsToUpdate.GetSize() != 0)
+            {
+                hr = UpdateUnloadedElement(this->UnloadedElementsToUpdate[0]);
+                if (FAILED(hr)) return hr;
+
+                hr = this->UnloadedElementsToUpdate.RemoveAt(0);
+                if (FAILED(hr)) return hr;
+            }
+
+<#+         conditions.Add("this->UnloadedElementsToUpdate.GetSize() != 0"); #>
+<#+     } #>
+<#+     if (needsLoop) { #>
+<#+         PopIndent(); #>
+            }
+            while (<#=string.Join(" || ", conditions)#>);
+<#+     } #>
+        }
+        // END Output_CompleteUpdate()
+<#+ }#>
+
+<#+ private void Output_FunctionBindings(BindUniverse bindUniverse)#>
+<#+ {#>
+        // BEGIN Output_FunctionBindings()
+        CSimpleHashTable<const wchar_t*, HRESULT (<#=bindUniverse.BindingsClassName#>::*)(int), CStringHashPolicy, CStringCompare> PendingFunctionBindings;
+
+<#+     foreach (FunctionStep functionStep in bindUniverse.BindPathSteps.Values.Where(s => s is FunctionStep))#>
+<#+     {#>
+
+        HRESULT Invoke_<#=functionStep.CodeName#>(int phase)
+        {
+            HRESULT hr = S_OK;
+
+<#+         foreach (var param in functionStep.Parameters.OrderBy(p => p.HasTryGetValue)) {#>
+<#+             if (param.HasTryGetValue && functionStep.RequiresSafeParameterRetrieval) {#>
+<#+                 if (param.AssignmentType.IsNullable) {#>
+            <#=param.AssignmentType.WRLDeclareSmartVar(param.Name + "Temp")#>
+<#+                 } else { #>
+            <#=param.AssignmentType.WRLDeclareSmartVar(param.Name + "Temp", "__WRL_NOINIT")#>
+<#+                 }#>
+            if (FAILED(<#=param.TryGetValueCodeName#>(<#=param.AssignmentType.WRLOutParam(param.Name + "Temp")#>))) { return hr; }
+            <#=param.AssignmentType.WRLNameNonSmartVar()#> <#=param.Name#> = <#=param.AssignmentType.WRLGetSmartVar(param.Name + "Temp")#>;
+<#+             } else {#>
+            // [debug] initializer type is <#=param.CodeGen().GetType().Name#>
+<#+                 if (param.ValueType.IsString()) {#>
+            ::Microsoft::WRL::Wrappers::HStringReference <#=param.Name#>Temp(<#=param.CodeGen().PathExpression#>);
+            HSTRING <#=param.Name#> = <#=param.Name#>Temp.Get();
+<#+                 } else { /*TODO FunctionPathParam is not yet tested*/#>
+            <#=param.ValueType.WRLNameNonSmartVar(ownType: true)#> <#=param.Name#> = <#=param.CodeGen().PathExpression#>;
+<#+                 }#>
+<#+             }#>
+
+<#+         }#>
+            HRESULT hrT = hr;
+<#+             PushIndent(Indent.ThreeTabs);#>
+<#=functionStep.CodeGen().PathExpression#>;
+<#+             PopIndent();#>
+            hr = hrT;
+            if (FAILED(hr)) return hr;
+
+<#+         foreach (int distinctPhase in functionStep.DistinctPhases) {#>
+<#+             Output_Binding_Phased_SetValue(distinctPhase, true, functionStep, true);#>
+<#+             Output_Binding_Phased_SetValue(distinctPhase, false, functionStep, true);#>
+<#+         }#>
+
+            return hr;
+        }
+<#+     }#>
+        // END Output_FunctionBindings()
+<#+ }#>
+
+<#+ private void Output_TryGetValueFunctions(BindUniverse bindUniverse)#>
+<#+ {#>
+        // BEGIN Output_TryGetValueFunctions(...)
+<#+     foreach (var step in bindUniverse.TryGetValueSteps)#>
+<#+     {#>
+
+        HRESULT <#=step.TryGetValueCodeName#>(<#=step.ValueType.WRLNameNonSmartVar(ownType: true)#>* val)
+        {
+            HRESULT hr = S_OK;
+
+<#+         if (step is RootStep || !step.Parent.IsIncludedInUpdate) {#>
+            HRESULT hrT = hr;
+<#+             PushIndent(Indent.ThreeTabs);#>
+<#=step.CodeGen().PathExpression#>;
+<#+             PopIndent();#>
+            hr = hrT;
+            if (SUCCEEDED(hr))
+            {
+                *val = <#=step.CodeGen().PathExpression.WRLOutVarName()#>;
+            }
+<#+         }#>
+<#+         else {#>
+            <#=step.Parent.ValueType.WRLDeclareSmartVar("objT")#>
+<#+             if (step.Parent.ValueType.IsNullable) {#>
+            if (SUCCEEDED(<#=step.Parent.TryGetValueCodeName#>(<#=step.Parent.ValueType.WRLOutParam("objT")#>)) && objT)
+<#+             } else { #>
+            if (SUCCEEDED(<#=step.Parent.TryGetValueCodeName#>(<#=step.Parent.ValueType.WRLOutParam("objT")#>)))
+<#+             } #>
+            {
+                <#=step.Parent.ValueType.WRLNameNonSmartVar()#> obj = <#=step.Parent.ValueType.WRLGetSmartVar("objT")#>;
+                HRESULT hrT = hr;
+<#+             PushIndent(Indent.FourTabs);#>
+<#=step.CodeGen().UpdateCallParam#>;
+<#+             PopIndent();#>
+                hr = hrT;
+                if (SUCCEEDED(hr))
+                {
+                    *val = <#=step.CodeGen().UpdateCallParam.WRLOutVarName()#>;
+                }
+            }
+            else
+            {
+                hr = TYPE_E_ELEMENTNOTFOUND;
+            }
+<#+         }#>
+
+            return hr;
+        }
+<#+     }#>
+        // END Output_TryGetValueFunctions(...)
+<#+ }#>
+
+<#+ private void Output_BindingSetValueFunction(BindAssignment ba)#>
+<#+ {#>
+        // BEGIN Output_BindingSetValueFunction(<#=ba.CodeName#>)
+<#+     if (ba.MemberType.IsNullable) { #>
+
+        static HRESULT Set_<#=ba.MemberDeclaringType.MemberFriendlyName()#>_<#=ba.MemberName#>(<#=ba.MemberTargetType.WRLNameInterface()#>* obj, <#=ba.MemberType.WRLNameNonSmartVar()#> value, HSTRING targetNullValue)
+        {
+            HRESULT hr = S_OK;
+
+            if (!value && targetNullValue)
+            {
+                HRESULT hrT = hr;
+<#+         PushIndent(Indent.FourTabs);#>
+<#+         LanguageSpecificString stringToNullValue = ba.MemberType.GetStringToThing("targetNullValue");#>
+<#=stringToNullValue.WRLName()#>
+<#+         PopIndent();#>
+                hr = hrT;
+                if (SUCCEEDED(hr))
+                {
+                    value = <#=stringToNullValue.WRLOutVarName()#>;
+                }
+            }
+<#+     } else { #>
+
+        static HRESULT Set_<#=ba.MemberDeclaringType.MemberFriendlyName()#>_<#=ba.MemberName#>(<#=ba.MemberTargetType.WRLNameInterface()#>* obj, <#=ba.MemberType.WRLNameNonSmartVar()#> value)
+        {
+            HRESULT hr = S_OK;
+<#+     }#>
+
+<#+     if (ba.IsAttachable) { #>
+            ::Microsoft::WRL::ComPtr<<#=ba.MemberDeclaringType.WRLNameStaticInterfaceSpecific("Set" + ba.MemberName)#>> objT;
+            hr = ::ABI::Windows::Foundation::GetActivationFactory(
+                ::Microsoft::WRL::Wrappers::HStringReference(<#=ba.MemberDeclaringType.ToRuntimeClassNameConstant()#>).Get(),
+                &objT);
+            if (SUCCEEDED(hr))
+            {
+                hr = objT->Set<#=ba.MemberName#>(obj, value);
+            }
+<#+     } else { #>
+            HRESULT hrT = hr;
+<#+         PushIndent(Indent.ThreeTabs);#>
+<#=ba.MemberTargetType.WRLDeclareQIIfNeeded(ba.MemberDeclaringType.WRLNameInterfaceSpecific("put_" + ba.MemberName), "obj", "pMemberDeclaringInterface")#>
+<#+         PopIndent();#>
+            hr = hrT;
+            if (SUCCEEDED(hr))
+            {
+                hr = pMemberDeclaringInterface->put_<#=ba.MemberName#>(value);
+            }
+<#+     }#>
+
+            return hr;
+        }
+        // END Output_BindingSetValueFunction(<#=ba.CodeName#>)
+<#+ }#>
+
+
+<#+     private string GetCacheArgumentStatement(BindPathStep step, string prefix, BindPathStep child)#>
+<#+     {#>
+<#+         return string.Format("{0}{1}",  prefix, child.CodeName);#>
+<#+     }#>
+
+<#+ private void Output_BindingSetters(BindUniverse bu)
+{
+    var distinctAsignmentsByMember = from ba in bu.BindAssignments.Where(ba => ba.HasSetValueHelper) group ba by ba.MemberFullName;
+    foreach (var item in distinctAsignmentsByMember) {
+        Output_BindingSetValueFunction(item.First());
+    }
+}#>
+
+<#+ private void Output_ApiInformationCall_Push(ApiInformation apiInformation, Indent indent)#>
+<#+ {#>
+<#+     if (apiInformation != null) { #>
+<#+         PushIndent(indent); #>
+        if (<#=Model.CodeInfo.ClassName.ShortName#>_<#= apiInformation.MemberFriendlyName #>)
+        {
+<#+         PopIndent(); #>
+<#+         PushIndent(); #>
+<#+     } #>
+<#+ } #>
+
+<#+ private void Output_ApiInformationCall_Pop(ApiInformation apiInformation, Indent indent)#>
+<#+ {#>
+<#+     if (apiInformation != null) { #>
+<#+         PopIndent(); #>
+<#+         PushIndent(indent); #>
+        }
+<#+         PopIndent(); #>
+<#+     } #>
+<#+ } #>
\ No newline at end of file
