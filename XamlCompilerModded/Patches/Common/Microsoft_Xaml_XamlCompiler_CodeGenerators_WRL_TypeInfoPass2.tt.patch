diff --git a/Microsoft/Xaml/XamlCompiler/CodeGenerators/WRL_TypeInfoPass2.tt b/Microsoft/Xaml/XamlCompiler/CodeGenerators/WRL_TypeInfoPass2.tt
new file mode 100644
index 0000000..39bf23b
--- /dev/null
+++ b/Microsoft/Xaml/XamlCompiler/CodeGenerators/WRL_TypeInfoPass2.tt
@@ -0,0 +1,488 @@
+ï»¿<#@ template language="C#" inherits="WRL_CodeGenerator<TypeInfoDefinition>" visibility="internal" linePragmas="false"#>
+<#@ import namespace="System.Linq" #>
+<#@ import namespace="Microsoft.Xaml.DirectUI" #>
+//------------------------------------------------------------------------------
+// <auto-generated>
+//     This code was generated by a trole.
+//
+//     Changes to this file may cause incorrect behavior and will be lost if
+//     the code is regenerated.
+// </auto-generated>
+//------------------------------------------------------------------------------
+#include "pch.h"
+
+#include "inc/TroleBoxer.h"
+
+bool __XAML_IsSameObject(IUnknown* punk1, IUnknown* punk2)
+{
+    if (!punk1 || !punk2)
+        return false;
+    if (punk1 == punk2)
+        return true;
+
+    ::Microsoft::WRL::ComPtr<IUnknown> punkI1;
+    ::Microsoft::WRL::ComPtr<IUnknown> punkI2;
+    return SUCCEEDED(punk1->QueryInterface(IID_PPV_ARGS(&punkI1)))
+        && SUCCEEDED(punk2->QueryInterface(IID_PPV_ARGS(&punkI2)))
+        && punkI1.Get() == punkI2.Get();
+}
+
+<#  if (ProjectInfo.GenerateIncrementalTypeInfo) { #>
+#ifdef XAML_TYPE_INFO_INC
+#include XAML_TYPE_INFO_INC
+#endif
+<#  } #>
+#include "XamlTypeInfo.xaml.g.h"
+
+<#  if (!ProjectInfo.GenerateIncrementalTypeInfo) { #>
+<#      foreach(string includeFile in Model.AllLocalXamlHeaderFiles) { #>
+#include "<#=includeFile#>"
+<#      } #>
+<#  } #>
+#include "XamlBindingInfo.xaml.g.hpp"
+<#  if (!ProjectInfo.GenerateIncrementalTypeInfo) { #>
+<#      foreach(string includeFile in Model.AllLocalHppGeneratedFiles) #>
+<#      { #>
+#include "<#=includeFile.Replace(".g.hpp", ".xaml.g.hpp")#>"
+<#      } #>
+<#  } #>
+
+using namespace Microsoft::WRL;
+
+namespace <#=Colonize(ProjectInfo.RootNamespace)#>
+{
+using TypeKind = <#=Projection(DUI.NamespaceWindowsUIXamlInterop)#>::TypeKind;
+
+<#  if (Model.TypeInfos.Any()) { #>
+<#      if (ProjectInfo.GenerateIncrementalTypeInfo) { #>
+<#          foreach(var entry in Model.TypeInfos.OrderBy(t => t.StandardName)) { #>
+<#              /*TODO IncludeTemplate<WRL_MetadataDelegates>(entry, ProjectInfo.ClassToHeaderFileMap.ContainsKey(entry.StandardName));*/#>
+<#          } #>
+<#      } else { #>
+<#          IncludeTemplate<WRL_TemplatedMetadataDelegates>(Model);#>
+<#      } #>
+
+enum TypeInfo_Flags
+{
+    TypeInfo_Flags_None                 = 0x00,
+    TypeInfo_Flags_IsLocalType          = 0x01,
+    TypeInfo_Flags_IsSystemType         = 0x02,
+    TypeInfo_Flags_IsReturnTypeStub     = 0x04,
+    TypeInfo_Flags_IsBindable           = 0x08,
+    TypeInfo_Flags_IsMarkupExtension    = 0x10, 
+};
+
+struct TypeInfo
+{
+    const wchar_t* typeName{nullptr};
+    const wchar_t* contentPropertyName{nullptr};
+    HRESULT (*activator)(::IInspectable**);
+    HRESULT (*collectionAdd)(::IInspectable*, ::IInspectable*);
+    HRESULT (*dictionaryAdd)(::IInspectable*, ::IInspectable*, ::IInspectable*);
+    HRESULT (*fromStringConverter)(XamlUserType*, HSTRING, ::IInspectable**);
+    int     baseTypeIndex;
+    int     firstMemberIndex;
+    int     firstEnumValueIndex;
+    int     createFromStringIndex;
+    TypeKind kindOfType;
+    unsigned int flags;
+<#  if (Features.NullableTypes.ExistsInVersion(ProjectInfo.TargetPlatformMinVersion)) { #>
+    int boxedTypeIndex;
+<#  } #>
+};
+
+<#  if (Model.TypeInfos.Where(x => x.IsDeprecated).FirstOrDefault() != null) #>
+<#  { #>
+#pragma warning( push )
+#pragma warning( disable : 4973 )
+<#  } #>
+<#  if (Model.TypeInfos.Where(entry => entry.HasCreateFromStringMethod).Any()) { #>
+
+XamlUserType::CreateFromStringFn CreateFromStringMethods[] =
+{
+<#      foreach(var entry in Model.TypeInfos.Where(entry => entry.HasCreateFromStringMethod)) { #>
+    //[](HSTRING value, IInspectable** pp) -> HRESULT { return ::winrt::box_value(<#=entry.CreateFromStringMethod.ResolvedName.WRLName()#>(value)); },
+    [](HSTRING value, IInspectable** pp) -> HRESULT { return E_NOTIMPL; },
+<#      }#>
+};
+<#  } #>
+
+const TypeInfo TypeInfos[] = 
+{
+<#  int entryIndex = 0; #>
+<#  int firstEnumValueIndex = 0; #>
+<#  int firstMemberIndex = 0; #>
+<#  int createFromStringIndex = 0; #>
+<#  foreach(var entry in Model.TypeInfos) #>
+<#  { #>
+<#      String isLocalType = entry.IsLocalType ? "TypeInfo_Flags_IsLocalType | " : "";#>
+<#      String isSystemType = entry.IsSystemType ? "TypeInfo_Flags_IsSystemType | " : "";#>
+<#      String isReturnTypeStub = entry.IsReturnTypeStub ? "TypeInfo_Flags_IsReturnTypeStub | " : "";#>
+<#      String isBindable = entry.IsBindable ? "TypeInfo_Flags_IsBindable | " : "";#>
+<#      String isMarkupExtension = entry.IsMarkupExtension ? "TypeInfo_Flags_IsMarkupExtension | " : "";#>
+<#      String baseTypeIndex = entry.BaseTypeStandardName.Length > 0 ? Model.TypeInfoIndexes[entry.BaseTypeStandardName].ToString() + ", // " + entry.BaseTypeStandardName : "-1,";#>
+<#      String boxedTypeIndex = entry.BoxedTypeStandardName.Length > 0 ? Model.TypeInfoIndexes[entry.BoxedTypeStandardName].ToString() + ", // " + entry.BoxedTypeStandardName : "-1,";#>
+<#      String kindofType = String.Format("TypeKind::TypeKind_{0}", entry.IsLocalType && !ProjectInfo.IsLibrary ? "Custom" : "Metadata");#>
+<#      String activator = entry.HasActivator ? $"&{entry.ActivatorName.WRLName()}" : "nullptr";#>
+<#      String collectionAdd = entry.IsCollection ? $"&{entry.CollectionAddName.WRLName()}" : "nullptr";#>
+<#      String dictionaryAdd = entry.IsDictionary ? $"&{entry.DictionaryAddName.WRLName()}" : "nullptr";#>
+<#      String fromStringConverter = entry.HasEnumValues ? $"&{entry.FromStringConverterName.WRLName()}" : "nullptr";#>
+<#      String createFromString = "-1";#>
+<#      if (entry.HasCreateFromStringMethod)#>
+<#      {#>
+<#          createFromString = createFromStringIndex.ToString();#>
+<#          createFromStringIndex++;#>
+<#      }#>
+<#      if (entry.HasMembers) #>
+<#      { #>
+<#          Model.TrackTypeMembers(entry, out firstMemberIndex); #>
+<#      } #>
+<#      if(entry.HasEnumValues) #>
+<#      { #>
+<#          Model.TrackTypeEnumValues(entry, out firstEnumValueIndex); #>
+<#      } #>
+    // <#= String.Format("{0,3}", entryIndex++) #>
+    L"<#=entry.StandardName#>", L"<#=entry.ContentPropertyName#>",
+    <#=activator#>, <#=collectionAdd#>, <#=dictionaryAdd#>, <#=fromStringConverter#>,
+    <#=baseTypeIndex#>
+    <#=firstMemberIndex#>, <#=firstEnumValueIndex#>, <#=createFromString#>, <#=kindofType#>,
+    <#=isLocalType#><#=isSystemType#><#=isReturnTypeStub#><#=isBindable#><#=isMarkupExtension#>TypeInfo_Flags_None,
+<#  if (Features.NullableTypes.ExistsInVersion(ProjectInfo.TargetPlatformMinVersion)) { #>
+    <#=boxedTypeIndex#>
+<#  } #>
+<#      firstEnumValueIndex += entry.EnumValues.Count(); #>
+<#      firstMemberIndex += entry.Members.Count(); #>
+<#  } #>
+    //  Last type here is for padding
+    L"", L"",
+    nullptr, nullptr, nullptr, nullptr,
+    -1, 
+    <#=firstMemberIndex#>, <#=firstEnumValueIndex#>, -1, TypeKind::TypeKind_Custom,
+    TypeInfo_Flags_None,
+};
+<#  if (Model.TypeInfos.Where(x => x.IsDeprecated).FirstOrDefault() != null) #>
+<#  { #>
+#pragma warning( pop )
+<#  } #>
+
+<#  entryIndex = 0; #>
+constexpr uint32_t TypeInfoLookup[] = { 
+<#  foreach(var entry in Model.TypeInfoLookup) #>
+<#  { #>
+    <#= String.Format("{0,3},   // {1,3}", entry, entryIndex++) #>
+<# } #>
+};
+<#  if (Model.EnumValues.Count() > 0) #>
+<#  { #>
+
+struct EnumValueInfo
+{
+    const wchar_t* name{nullptr};
+    int eValue;
+};
+
+const EnumValueInfo EnumValues[] =
+{ 
+<#      foreach (var enumValue in Model.EnumValues) #>
+<#      { #>
+<#          var enumFullName = enumValue.TypeInfo.FullName.WRLName(); #>
+<#          var lastDot = enumFullName.LastIndexOf("::", StringComparison.Ordinal); #>
+<#          var enumNamespace = enumFullName.Substring(0, lastDot); #>
+<#          var enumName = enumFullName.Substring(lastDot + 2); #>
+    L"<#=enumValue.ValueName#>", static_cast<int>(<#=enumNamespace#>::<#=enumName#>_<#=enumValue.ValueName#>),
+<#      } #>
+};
+<#  } #>
+<#  if (Model.MemberInfos.Count() > 0) #>
+<#  { #>
+
+struct MemberInfo
+{
+    const wchar_t* shortName{nullptr};
+    HRESULT (*getter)(::IInspectable*, ::IInspectable**);
+    HRESULT (*setter)(::IInspectable*, ::IInspectable*);
+    int typeIndex;
+    int targetTypeIndex;
+    bool isReadOnly;
+    bool isDependencyProperty;
+    bool isAttachable;
+};
+
+<#      if (Model.MemberInfos.Where(x => x.IsDeprecated).FirstOrDefault() != null) #>
+<#      { #>
+#pragma warning( push )
+#pragma warning( disable : 4973 )
+<#      } #>
+const MemberInfo MemberInfos[] = 
+{
+<#      entryIndex = 0; #>
+<#      foreach(var entry in Model.MemberInfos) #>
+<#      { #>
+<#      String isReadOnly = entry.HasPublicGetter && !entry.HasPublicSetter ? "true, " : "false,"; #>
+<#      String isDependencyProperty = entry.IsDependencyProperty ? "true, " : "false,"; #>
+<#      String isAttachable = entry.IsAttachable ? "true, " : "false,"; #>
+<#      String targetTypeIndex = entry.TargetType != null ? Model.TypeInfoIndexes[entry.TargetType.StandardName].ToString() + ", // " + entry.TargetType.StandardName : "-1,";#>
+    // <#= String.Format("{0,3}", entryIndex++) #> - <#=entry.DeclaringType.StandardName#>.<#=entry.Name#>
+    L"<#=entry.Name#>",
+<#          if (entry.HasGetAttachableMember) { #>
+    &<#=entry.GetAttachableMemberName#>,
+<#          } else if (entry.HasGetValueTypeMember) { #>
+    &<#=entry.GetValueTypeMemberName#>,
+<#          } else if (entry.HasGetReferenceTypeMember) { #>
+    &<#=entry.GetReferenceTypeMemberName#>,
+<#          } else { #>
+    nullptr,
+<#          } #>
+<#          if (entry.HasSetAttachableMember) { #>
+    &<#=entry.SetAttachableMemberName#>,
+<#          } else if (entry.HasSetEnumMember) { #>
+    &<#=entry.SetEnumMemberName#>,
+<#          } else if (entry.HasSetValueTypeMember) { #>
+    &<#=entry.SetValueTypeMemberName#>,
+<#          } else if (entry.HasSetReferenceTypeMember) { #>
+    &<#=entry.SetReferenceTypeMemberName#>,
+<#          } else { #>
+    nullptr,
+<#          } #>
+    <#=Model.TypeInfoIndexes[entry.Type.StandardName]#>, // <#=entry.Type.StandardName#>
+    <#=targetTypeIndex#>
+    <#=isReadOnly#> <#=isDependencyProperty#> <#=isAttachable#>
+<#      } #>
+};
+<#      if (Model.MemberInfos.Where(x => x.IsDeprecated).FirstOrDefault() != null) #>
+<#      { #>
+#pragma warning( pop )
+<#      } #>
+
+const wchar_t* GetShortName(const wchar_t* longName)
+{
+    const wchar_t* separator = wcsrchr(longName, '.');
+    return separator ? separator + 1: longName;
+}
+<#  } #>
+
+const TypeInfo* GetTypeInfo(const wchar_t* typeName)
+{
+    size_t typeNameLength = wcslen(typeName);
+    if (typeNameLength < _countof(TypeInfoLookup) - 1)
+    {
+        uint32_t begin = TypeInfoLookup[typeNameLength];
+        uint32_t end = TypeInfoLookup[typeNameLength + 1];
+        for (uint32_t i = begin; i < end; ++i)
+        {
+            if (wcscmp(typeName, TypeInfos[i].typeName) == 0)
+            {
+                return &TypeInfos[i];
+            }
+        }
+    }
+    return nullptr;
+}
+<#      if (Model.MemberInfos.Count() > 0) { #>
+
+const MemberInfo* GetMemberInfo(const wchar_t* longMemberName)
+{
+    const MemberInfo* pMemberInfo = nullptr;
+
+    const wchar_t* pszDot = wcsrchr(longMemberName, L'.');
+    if (pszDot)
+    {
+        const size_t cchTypeName = static_cast<size_t>(pszDot - longMemberName);
+        size_t cbTypeName = sizeof(wchar_t) * (cchTypeName + 1 /*NUL*/);
+        wchar_t* pszTypeName = new wchar_t[cbTypeName / sizeof(wchar_t)];
+        if (pszTypeName)
+        {
+            memcpy_s(pszTypeName, cbTypeName, longMemberName, sizeof(wchar_t) * cchTypeName);
+            pszTypeName[cchTypeName] = 0;
+
+            const TypeInfo* pTypeInfo = GetTypeInfo(pszTypeName);
+            if (pTypeInfo)
+            {
+                const TypeInfo* pNextTypeInfo = pTypeInfo + 1;
+                const wchar_t* const shortMemberName = GetShortName(longMemberName);
+                for (size_t i = pTypeInfo->firstMemberIndex; i < pNextTypeInfo->firstMemberIndex; ++i)
+                {
+                    if (wcscmp(shortMemberName, MemberInfos[i].shortName) == 0)
+                    {
+                        pMemberInfo = &MemberInfos[i];
+                        break;
+                    }
+                }
+            }
+
+            delete[] pszTypeName;
+        }
+    }
+
+    return pMemberInfo;
+}
+<#      } #>
+<#  } #>
+
+HRESULT XamlTypeInfoProvider::_EnsureOtherProviders()
+{
+    HRESULT hr = S_OK;
+
+<#      if (ProjectInfo.GenerateProviderCode && SchemaInfo.OtherMetadataProviders.Any()) { #>
+    if (!_otherProviders.GetSize())
+    {
+<#          foreach(var provider in SchemaInfo.OtherMetadataProviders) { #>
+        {
+            ::Microsoft::WRL::ComPtr<<#=Projection(DUI.NamespaceWindowsUIXamlMarkup)#>::IXamlMetadataProvider> otherProvider;
+            hr = ABI::Windows::Foundation::ActivateInstance(
+                ::Microsoft::WRL::Wrappers::HStringReference(RuntimeClass_<#=provider.StandardName.Replace('.', '_')#>).Get(),
+                &otherProvider);
+            if (SUCCEEDED(hr))
+            {
+                hr = _otherProviders.Add(std::move(otherProvider));
+            }
+        }
+<#          } #>
+    }
+
+<#      } #>
+    return hr;
+}
+
+<#  if (!Model.TypeInfos.Any()) { #>
+HRESULT XamlTypeInfoProvider::_CreateXamlType(const wchar_t*, IXamlType** ppXamlType)
+{
+    // No local types
+    *ppXamlType = nullptr;
+    return S_OK;
+}
+<#  } else  { #>
+HRESULT XamlTypeInfoProvider::_CreateXamlType(const wchar_t* typeName, IXamlType** ppXamlType)
+{
+    *ppXamlType = nullptr;
+    HRESULT hr = TYPE_E_ELEMENTNOTFOUND;
+
+    const TypeInfo* pTypeInfo = GetTypeInfo(typeName);
+    const TypeInfo* pNextTypeInfo = pTypeInfo + 1;
+    if (pTypeInfo && pNextTypeInfo)
+    {
+        if (pTypeInfo->flags & TypeInfo_Flags_IsSystemType)
+        {
+            ::Microsoft::WRL::ComPtr<XamlSystemBaseType> systemBaseType;
+            hr = MakeAndInitialize<XamlSystemBaseType>(&systemBaseType, typeName);
+            if (SUCCEEDED(hr))
+            {
+                *ppXamlType = systemBaseType.Detach();
+            }
+        }
+        else
+        {
+            const wchar_t* baseName = pTypeInfo->baseTypeIndex >= 0 ? TypeInfos[pTypeInfo->baseTypeIndex].typeName : L"";
+            const wchar_t* boxedName = pTypeInfo->boxedTypeIndex >= 0 ? TypeInfos[pTypeInfo->boxedTypeIndex].typeName : L"";
+            ::Microsoft::WRL::ComPtr<IXamlType> xamlType;
+            hr = GetXamlTypeByName(Wrappers::HStringReference(baseName).Get(), &xamlType);
+            if (SUCCEEDED(hr))
+            {
+                ::Microsoft::WRL::ComPtr<XamlUserType> userType;
+                hr = MakeAndInitialize<XamlUserType>(&userType, this, pTypeInfo->typeName, xamlType.Get());
+                if (SUCCEEDED(hr))
+                {
+                    userType->_kindOfType = pTypeInfo->kindOfType;
+                    userType->_activator = pTypeInfo->activator;
+                    userType->_collectionAdd = pTypeInfo->collectionAdd;
+                    userType->_dictionaryAdd = pTypeInfo->dictionaryAdd;
+                    userType->_fromStringConverter = pTypeInfo->fromStringConverter;
+                    userType->SetContentPropertyName(pTypeInfo->contentPropertyName);
+                    userType->SetLocalType(pTypeInfo->flags & TypeInfo_Flags_IsLocalType);
+                    userType->SetReturnTypeStub(pTypeInfo->flags & TypeInfo_Flags_IsReturnTypeStub);
+                    userType->SetBindable(pTypeInfo->flags & TypeInfo_Flags_IsBindable);
+                    userType->SetMarkupExtension(pTypeInfo->flags & TypeInfo_Flags_IsMarkupExtension);
+                    userType->_createFromStringMethod = nullptr;
+<#  if (Model.TypeInfos.Where(entry => entry.HasCreateFromStringMethod).Any()) { #>
+                    if (pTypeInfo->createFromStringIndex != -1)
+                    {
+                        userType->_createFromStringMethod = CreateFromStringMethods[pTypeInfo->createFromStringIndex];
+                    }
+<#  } #>
+<#  if (Features.NullableTypes.ExistsInVersion(ProjectInfo.TargetPlatformMinVersion)) { #>
+                    {
+                        ::Microsoft::WRL::ComPtr<IXamlType> boxedType;
+                        if (SUCCEEDED(GetXamlTypeByName(Wrappers::HStringReference(boxedName).Get(), &boxedType)))
+                        {
+                            userType->SetBoxedType(boxedType.Get());
+                        }
+                    }
+<#  } #>
+<#  if (Model.MemberInfos.Any()) { #>
+                    for (int i = pTypeInfo->firstMemberIndex; i < pNextTypeInfo->firstMemberIndex; ++i)
+                    {
+                        userType->AddMemberName(MemberInfos[i].shortName);
+                    }
+<#  } #>
+<#  if (Model.EnumValues.Any()) { #>
+                    {
+                        ::Microsoft::WRL::ComPtr<::ABI::Windows::Foundation::IPropertyValueStatics> propertyValueStatics;
+                        HRESULT hrInner = ::ABI::Windows::Foundation::GetActivationFactory(
+                            ::Microsoft::WRL::Wrappers::HStringReference(RuntimeClass_Windows_Foundation_PropertyValue).Get(),
+                            &propertyValueStatics);
+                        for (int i = pTypeInfo->firstEnumValueIndex; SUCCEEDED(hrInner) && i < pNextTypeInfo->firstEnumValueIndex; ++i)
+                        {
+                            ::Microsoft::WRL::ComPtr<::ABI::Windows::Foundation::IPropertyValue> enumValue;
+                            if (SUCCEEDED(propertyValueStatics->CreateInt32(EnumValues[i].eValue, &enumValue)))
+                            {
+                                userType->AddEnumValue(EnumValues[i].name, enumValue.Get());
+                            }
+                        }
+                    }
+<#  } #>
+
+                    *ppXamlType = userType.Detach();
+                }
+            }
+        }
+    }
+
+    if (hr == TYPE_E_ELEMENTNOTFOUND)
+    {
+        hr = S_OK; // The framework expects this function to return S_OK even if the type is not found
+    }
+
+    return hr;
+}
+<#  } #>
+
+<#  if (!Model.MemberInfos.Any()) { #>
+HRESULT XamlTypeInfoProvider::_CreateXamlMember(const wchar_t* longMemberName, IXamlMember** ppXamlMember)
+{
+    // No local properties
+    *ppXamlMember = nullptr;
+    return S_OK;
+}
+<#  } else { #>
+HRESULT XamlTypeInfoProvider::_CreateXamlMember(const wchar_t* longMemberName, IXamlMember** ppXamlMember)
+{
+    *ppXamlMember = nullptr;
+    HRESULT hr = TYPE_E_ELEMENTNOTFOUND;
+
+    const MemberInfo* pMemberInfo = GetMemberInfo(longMemberName);
+    if (pMemberInfo)
+    {
+        ::Microsoft::WRL::ComPtr<XamlMember> xamlMember;
+        hr = MakeAndInitialize<XamlMember>(&xamlMember, this, pMemberInfo->shortName, TypeInfos[pMemberInfo->typeIndex].typeName);
+        if (SUCCEEDED(hr))
+        {
+            xamlMember->_getter = pMemberInfo->getter;
+            xamlMember->_setter = pMemberInfo->setter;
+            xamlMember->SetTargetTypeName(pMemberInfo->targetTypeIndex >= 0 ? TypeInfos[pMemberInfo->targetTypeIndex].typeName : L"");
+            xamlMember->SetReadOnly(pMemberInfo->isReadOnly);
+            xamlMember->SetDependencyProperty(pMemberInfo->isDependencyProperty);
+            xamlMember->SetAttachable(pMemberInfo->isAttachable);
+
+            *ppXamlMember = xamlMember.Detach();
+        }
+    }
+
+    if (hr == TYPE_E_ELEMENTNOTFOUND)
+    {
+        hr = S_OK; // The framework expects this function to return S_OK even if the member is not found
+    }
+
+    return hr;
+}
+<#  } #>
+} // namespace
