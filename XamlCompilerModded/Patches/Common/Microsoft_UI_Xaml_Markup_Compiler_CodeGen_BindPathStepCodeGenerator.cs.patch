diff --git a/Microsoft/UI/Xaml/Markup/Compiler/CodeGen/BindPathStepCodeGenerator.cs b/Microsoft/UI/Xaml/Markup/Compiler/CodeGen/BindPathStepCodeGenerator.cs
index 15afa7c..7c798cf 100644
--- a/Microsoft/UI/Xaml/Markup/Compiler/CodeGen/BindPathStepCodeGenerator.cs
+++ b/Microsoft/UI/Xaml/Markup/Compiler/CodeGen/BindPathStepCodeGenerator.cs
@@ -5,7 +5,8 @@ namespace Microsoft.UI.Xaml.Markup.Compiler.CodeGen;
 
 internal abstract class BindPathStepCodeGenerator<T> : CodeGeneratorBase<T>, IBindPathStepCodeGen where T : BindPathStep
 {
-	public virtual ICodeGenOutput MemberAccessOperator => new LanguageSpecificString(() => (!base.Instance.ValueType.UnderlyingType.IsValueType) ? "->" : ".", () => ".", () => ".", () => ".");
+	public virtual ICodeGenOutput MemberAccessOperator => new LanguageSpecificString(() => (!base.Instance.ValueType.UnderlyingType.IsValueType) ? "->" : ".", () => ".", () => ".", () => ".",
+		wrl: () => throw new NotSupportedException("Without projections, the same member access operator cannot be used for both static and non-static members. Please implement different branches for each case instead."));
 
 	public abstract ICodeGenOutput PathExpression { get; }
 
@@ -21,6 +22,13 @@ internal abstract class BindPathStepCodeGenerator<T> : CodeGeneratorBase<T>, IBi
 	{
 		ICodeGenOutput pathExpression = base.Instance.CodeGen().PathExpression;
 		string cppWinrtNameNoParen = pathExpression.CppWinRTName().TrimEnd(')', '(');
-		return new LanguageSpecificString(() => pathExpression.CppCXName() + " = " + value.CppCXName(), () => cppWinrtNameNoParen + "(" + value.CppWinRTName() + ")", () => pathExpression.CSharpName() + " = " + value.CSharpName(), () => pathExpression.VBName() + " = " + value.VBName());
+		return new LanguageSpecificString(() => pathExpression.CppCXName() + " = " + value.CppCXName(), () => cppWinrtNameNoParen + "(" + value.CppWinRTName() + ")", () => pathExpression.CSharpName() + " = " + value.CSharpName(), () => pathExpression.VBName() + " = " + value.VBName(),
+			wrl: () => throw new NotSupportedException($"Impossible to make universal assignment expressions without projections. Please implement a specialized PathSetExpression for {typeof(T).Name}."));
+	}
+
+	// @MOD WRL support
+	protected string WRL_InternalGetTempVarName(string type_mustUseNameof, string suffix)
+	{
+		return $"_{Instance.CodeName}_{Instance.GetType().Name}_{type_mustUseNameof}_{suffix}";
 	}
 }
