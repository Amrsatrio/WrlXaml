diff --git a/Microsoft/Xaml/XamlCompiler/CodeGenerators/WRL_BindingInfoPass1.tt b/Microsoft/Xaml/XamlCompiler/CodeGenerators/WRL_BindingInfoPass1.tt
new file mode 100644
index 0000000..499d018
--- /dev/null
+++ b/Microsoft/Xaml/XamlCompiler/CodeGenerators/WRL_BindingInfoPass1.tt
@@ -0,0 +1,351 @@
+ï»¿<#@ template language="C#" inherits="WRL_CodeGenerator<BindingInfoDefinition>" visibility="internal" linePragmas="false"#>
+<#@ import namespace="Microsoft.Xaml.DirectUI" #>
+//------------------------------------------------------------------------------
+// <auto-generated>
+//     This code was generated by a trole.
+//
+//     Changes to this file may cause incorrect behavior and will be lost if
+//     the code is regenerated.
+// </auto-generated>
+//------------------------------------------------------------------------------
+#pragma once
+
+#include "TroleBoxer.h"
+
+namespace <#=Colonize(ProjectInfo.RootNamespace)#>
+{
+    using IDataContextChangedEventArgs = <#=Projection(DUI.NamespaceWindowsUIXaml)#>::IDataContextChangedEventArgs;
+    using IDependencyObject = <#=Projection(DUI.NamespaceWindowsUIXaml)#>::IDependencyObject;
+    using IDependencyProperty = <#=Projection(DUI.NamespaceWindowsUIXaml)#>::IDependencyProperty;
+    using IFrameworkElement = <#=Projection(DUI.NamespaceWindowsUIXaml)#>::IFrameworkElement;
+    using IFrameworkElement2 = <#=Projection(DUI.NamespaceWindowsUIXaml)#>::IFrameworkElement2;
+    using INotifyCollectionChanged = <#=Projection(DUI.NamespaceWindowsUIXamlInterop)#>::INotifyCollectionChanged;
+    using INotifyPropertyChanged = <#=Projection(DUI.NamespaceWindowsUIXamlData)#>::INotifyPropertyChanged;
+    using IPropertyChangedEventArgs = <#=Projection(DUI.NamespaceWindowsUIXamlData)#>::IPropertyChangedEventArgs;
+    using INotifyCollectionChangedEventArgs = <#=Projection(DUI.NamespaceWindowsUIXamlInterop)#>::INotifyCollectionChangedEventArgs;
+    using IContainerContentChangingEventArgs = <#=Projection(DUI.NamespaceWindowsUIXamlControls)#>::IContainerContentChangingEventArgs;
+    using IVectorChangedEventArgs = <#=Projection(DUI.NamespaceWindowsFoundationCollections)#>::IVectorChangedEventArgs;
+<# if (ProjectInfo.IsInputValidationEnabled) { #>
+    using INotifyDataErrorInfo = <#=Projection(DUI.NamespaceWindowsUIXamlData)#>::INotifyDataErrorInfo;
+    using IDataErrorsChangedEventArgs = <#=Projection(DUI.NamespaceWindowsUIXamlData)#>::IDataErrorsChangedEventArgs;
+<# } #>
+
+    class XamlBindings;
+
+    struct IXamlBindings
+    {
+        virtual ~IXamlBindings() {};
+        virtual bool IsInitialized() = 0;
+        virtual HRESULT Update() = 0;
+        virtual HRESULT SetDataRoot(IInspectable* data, bool* pfSet) = 0;
+        virtual void StopTracking() = 0;
+        virtual HRESULT Connect(int connectionId, IInspectable* target) = 0;
+        virtual HRESULT Recycle() = 0;
+        virtual HRESULT ProcessBindings(IInspectable* item, int itemIndex, int phase, int* nextPhase) = 0;
+        virtual HRESULT SubscribeForDataContextChanged(IFrameworkElement* object, XamlBindings* handler) = 0;
+<# if (Features.xLoad.ExistsInVersion(base.ProjectInfo.TargetPlatformMinVersion)) { #>
+        virtual HRESULT DisconnectUnloadedObject(int connectionId) = 0;
+<# } #>
+    };
+
+    struct IXamlBindingTracking
+    {
+        virtual HRESULT PropertyChanged(IInspectable* sender, IPropertyChangedEventArgs* e) = 0;
+        virtual HRESULT CollectionChanged(IInspectable* sender, INotifyCollectionChangedEventArgs* e) = 0;
+        virtual HRESULT DependencyPropertyChanged(IDependencyObject* sender, IDependencyProperty* prop) = 0;
+        virtual HRESULT VectorChanged(IInspectable* sender, IVectorChangedEventArgs* e) = 0;
+        virtual HRESULT MapChanged(IInspectable* sender, <#=Projection(DUI.NamespaceWindowsFoundationCollections)#>::IMapChangedEventArgs<HSTRING>* e) = 0;
+<# if (ProjectInfo.IsInputValidationEnabled) { #>
+        virtual HRESULT ErrorsChanged(IInspectable* sender, IDataErrorsChangedEventArgs* e) = 0;
+<# } #>
+    };
+
+    class XamlBindings
+        : public ::Microsoft::WRL::RuntimeClass<
+              <#=Projection(DUI.NamespaceWindowsUIXaml)#>::IDataTemplateExtension
+            , <#=Projection(DUI.NamespaceWindowsUIXamlMarkup)#>::IComponentConnector
+            , <#=Projection(DUI.NamespaceWindowsUIXamlMarkup)#>::IDataTemplateComponent
+        >
+    {
+    public:
+        XamlBindings();
+        ~XamlBindings() override;
+
+        HRESULT RuntimeClassInitialize(IXamlBindings* pBindings);
+
+        // IComponentConnector
+        STDMETHODIMP Connect(int connectionId, IInspectable* target) override;
+
+        // IDataTemplateComponent
+        STDMETHODIMP ProcessBindings(IInspectable* item, int itemIndex, int phase, int* nextPhase) override;
+        STDMETHODIMP Recycle() override;
+
+        // IDataTemplateExtension
+        STDMETHODIMP ProcessBinding(UINT phase, boolean* result) override;
+        STDMETHODIMP ProcessBindings(IContainerContentChangingEventArgs* args, int* nextPhase) override;
+        STDMETHODIMP ResetTemplate() override;
+
+        HRESULT Initialize();
+        HRESULT Update();
+        void StopTracking();
+        HRESULT Loading(IFrameworkElement* src, IInspectable* data);
+        HRESULT DataContextChanged(IFrameworkElement* sender, IDataContextChangedEventArgs* args);
+        HRESULT SubscribeForDataContextChanged(IFrameworkElement* object);
+<# if (Features.xLoad.ExistsInVersion(base.ProjectInfo.TargetPlatformMinVersion)) { #>
+        virtual HRESULT DisconnectUnloadedObject(int connectionId);
+<# } #>
+
+    private:
+        IXamlBindings* _pBindings;
+    };
+
+    template <typename TBindingsTracking>
+    struct XamlBindingsBase : IXamlBindings
+    {
+    protected:
+        bool _isInitialized = false;
+        ::Microsoft::WRL::ComPtr<TBindingsTracking> _bindingsTracking;
+        EventRegistrationToken _dataContextChangedToken {};
+        static const int NOT_PHASED = (1 << 31);
+        static const int DATA_CHANGED = (1 << 30);
+
+        XamlBindingsBase() = default;
+
+        ~XamlBindingsBase() override
+        {
+            if (_bindingsTracking)
+            {
+                _bindingsTracking->SetListener(nullptr);
+            }
+        }
+
+        virtual HRESULT ReleaseAllListeners()
+        {
+            // Overridden in the binding class as needed.
+            return S_OK;
+        }
+
+    public:
+        HRESULT InitializeTracking(IXamlBindingTracking* pBindingsTracking)
+        {
+            HRESULT hr = ::Microsoft::WRL::MakeAndInitialize<TBindingsTracking>(&_bindingsTracking);
+            if (SUCCEEDED(hr))
+            {
+                _bindingsTracking->SetListener(pBindingsTracking);
+            }
+
+            return hr;
+        }
+
+        void StopTracking() override
+        {
+            ReleaseAllListeners();
+            _isInitialized = false;
+        }
+
+        bool IsInitialized() override
+        {
+            return _isInitialized;
+        }
+
+        HRESULT SubscribeForDataContextChanged(IFrameworkElement* object, XamlBindings* handler) override
+        {
+            ::Microsoft::WRL::ComPtr<IFrameworkElement2> object2;
+            HRESULT hr = object->QueryInterface(IID_PPV_ARGS(&object2));
+            if (SUCCEEDED(hr))
+            {
+                hr = object2->add_DataContextChanged(
+                    ::Microsoft::WRL::Callback<__FITypedEventHandler_2_Windows__CUI__CXaml__CFrameworkElement_Windows__CUI__CXaml__CDataContextChangedEventArgs>(
+                        handler, &XamlBindings::DataContextChanged).Get(), &_dataContextChangedToken);
+            }
+
+            return hr;
+        }
+
+        HRESULT Recycle() override
+        {
+            // Overridden in the binding class as needed.
+            return S_OK;
+        }
+
+        HRESULT ProcessBindings(IInspectable*, int, int, int* nextPhase) override
+        {
+            // Overridden in the binding class as needed.
+            *nextPhase = -1;
+            return S_OK;
+        }
+    };
+
+    class XamlBindingTrackingBase
+        : public ::Microsoft::WRL::Implements<Microsoft::WRL::RuntimeClassFlags<Microsoft::WRL::ClassicCom>, IUnknown>
+    {
+public:
+        XamlBindingTrackingBase();
+        void SetListener(IXamlBindingTracking* pBindings);
+
+        // Event handlers
+        HRESULT PropertyChanged(IInspectable* sender, IPropertyChangedEventArgs* e);
+        HRESULT CollectionChanged(IInspectable* sender, INotifyCollectionChangedEventArgs* e);
+        HRESULT DependencyPropertyChanged(IDependencyObject* sender, IDependencyProperty* prop);
+        HRESULT VectorChanged(IInspectable* sender, IVectorChangedEventArgs* e);
+        HRESULT MapChanged(IInspectable* sender, <#=Projection(DUI.NamespaceWindowsFoundationCollections)#>::IMapChangedEventArgs<HSTRING>* e);
+<# if (ProjectInfo.IsInputValidationEnabled) { #>
+        HRESULT ErrorsChanged(IInspectable* sender, IDataErrorsChangedEventArgs* e);
+<# } #>
+
+        // Listener update functions
+        HRESULT UpdatePropertyChangedListener(INotifyPropertyChanged* obj, ::Microsoft::WRL::ComPtr<INotifyPropertyChanged>& cache, EventRegistrationToken& token);
+        HRESULT UpdatePropertyChangedListener(INotifyPropertyChanged* obj, ::Microsoft::WRL::WeakRef& cacheRef, EventRegistrationToken& token);
+        HRESULT UpdateCollectionChangedListener(INotifyCollectionChanged* obj, ::Microsoft::WRL::ComPtr<INotifyCollectionChanged>& cache, EventRegistrationToken& token);
+        HRESULT UpdateDependencyPropertyChangedListener(IDependencyObject* obj, IDependencyProperty* property, ::Microsoft::WRL::ComPtr<IDependencyObject>& cache, INT64& token);
+        HRESULT UpdateDependencyPropertyChangedListener(IDependencyObject* obj, IDependencyProperty* property, ::Microsoft::WRL::WeakRef& cacheRef, INT64& token);
+<# if (ProjectInfo.IsInputValidationEnabled) { #>
+        HRESULT UpdateDataErrorsChangedListener(INotifyDataErrorInfo* obj, ::Microsoft::WRL::ComPtr<INotifyDataErrorInfo>& cache, EventRegistrationToken& token);
+        HRESULT UpdateDataErrorsChangedListener(INotifyDataErrorInfo* obj, ::Microsoft::WRL::WeakRef& cacheRef, EventRegistrationToken& token);
+<# } #>
+
+    private:
+        IXamlBindingTracking* _pBindingsTrackingWeakRef{nullptr};
+    };
+
+    template <typename T>
+    struct ResolveHelper
+    {
+        static HRESULT Resolve(const ::Microsoft::WRL::WeakRef& wr, T** result)
+        {
+            return wr.CopyTo(result);
+        }
+    };
+
+    template <>
+    struct ResolveHelper<HSTRING>
+    {
+        using ResolveType = ::ABI::Windows::Foundation::IReference<HSTRING>;
+        static HRESULT Resolve(const ::Microsoft::WRL::WeakRef& wr, HSTRING* result)
+        {
+            *result = nullptr;
+
+            ::Microsoft::WRL::ComPtr<ResolveType> spReference;
+            HRESULT hr = wr.As(&spReference);
+            if (SUCCEEDED(hr))
+            {
+                hr = spReference->get_Value(result);
+            }
+
+            return hr;
+        }
+    };
+
+    template <typename T, typename TBindingsTracking>
+    struct ReferenceTypeXamlBindings : XamlBindingsBase<TBindingsTracking>
+    {
+    protected:
+        ReferenceTypeXamlBindings() {}
+
+        virtual HRESULT Update_(T*, int)
+        {
+            // Overridden in the binding class as needed.
+            return S_OK;
+        }
+
+    public:
+        HRESULT GetDataRoot(T** result)
+        {
+            return ResolveHelper<T>::Resolve(_dataRoot, result);
+        }
+
+        HRESULT SetDataRoot(IInspectable* data, bool* pfSet) override
+        {
+            *pfSet = false;
+            HRESULT hr = S_OK;
+
+            if (data)
+            {
+                ::Microsoft::WRL::ComPtr<T> spUnboxed;
+                hr = TroleBoxer::UnboxValue<T>(data, &spUnboxed);
+                if (SUCCEEDED(hr))
+                {
+                    hr = ::Microsoft::WRL::AsWeak(spUnboxed.Get(), &_dataRoot);
+                    if (SUCCEEDED(hr))
+                    {
+                        *pfSet = true;
+                    }
+                }
+            }
+
+            return hr;
+        }
+
+        HRESULT Update() override
+        {
+            ::Microsoft::WRL::ComPtr<T> spDataRoot;
+            HRESULT hr = GetDataRoot(&spDataRoot);
+            if (SUCCEEDED(hr))
+            {
+                hr = Update_(spDataRoot.Get(), this->NOT_PHASED);
+                if (SUCCEEDED(hr))
+                {
+                    this->_isInitialized = true;
+                }
+            }
+
+            return hr;
+        }
+
+    private:
+         ::Microsoft::WRL::WeakRef _dataRoot;
+    };
+
+    template <typename T, typename TBindingsTracking>
+    struct ValueTypeXamlBindings : XamlBindingsBase<TBindingsTracking>
+    {
+    protected:
+        ValueTypeXamlBindings() {}
+
+        virtual HRESULT Update_(T, int)
+        {
+            // Overridden in the binding class as needed.
+            return S_OK;
+        }
+
+    public:
+        HRESULT GetDataRoot(T* result)
+        {
+            *result = _dataRoot;
+            return S_OK;
+        }
+
+        HRESULT SetDataRoot(IInspectable* data, bool* pfSet) override
+        {
+            HRESULT hr = S_OK;
+            *pfSet = false;
+
+            if (data)
+            {
+                hr = TroleBoxer::UnboxValue<T>(data, &_dataRoot);
+                *pfSet = true;
+            }
+
+            return hr;
+        }
+
+        HRESULT Update() override
+        {
+            T dataRoot;
+            HRESULT hr = GetDataRoot(&dataRoot);
+            if (SUCCEEDED(hr))
+            {
+                hr = Update_(dataRoot, this->NOT_PHASED);
+                if (SUCCEEDED(hr))
+                {
+                    this->_isInitialized = true;
+                }
+            }
+
+            return hr;
+        }
+
+    private:
+        T _dataRoot;
+    };
+}
