diff --git a/Microsoft/Xaml/XamlCompiler/CodeGenerators/WRL_TypeInfoPass1Impl.tt b/Microsoft/Xaml/XamlCompiler/CodeGenerators/WRL_TypeInfoPass1Impl.tt
new file mode 100644
index 0000000..368c6a1
--- /dev/null
+++ b/Microsoft/Xaml/XamlCompiler/CodeGenerators/WRL_TypeInfoPass1Impl.tt
@@ -0,0 +1,903 @@
+ï»¿<#@ template language="C#" inherits="WRL_CodeGenerator<TypeInfoDefinition>" visibility="internal" linePragmas="false"#>
+<#@ import namespace="Microsoft.Xaml.DirectUI" #>
+//------------------------------------------------------------------------------
+// <auto-generated>
+//     This code was generated by a trole.
+//
+//     Changes to this file may cause incorrect behavior and will be lost if
+//     the code is regenerated.
+// </auto-generated>
+//------------------------------------------------------------------------------
+#include "pch.h"
+
+#include <wrl/implements.h>
+#include <wrl/wrappers/corewrappers.h>
+
+#include "XamlTypeInfo.xaml.g.h"
+#include "XamlMetaDataProvider.h"
+#include "inc/TroleBoxer.h"
+
+using namespace Microsoft::WRL;
+
+namespace <#=Colonize(ProjectInfo.RootNamespace)#>
+{
+    using namespace <#=Projection(DUI.NamespaceWindowsUIXamlMarkup)#>;
+    using namespace <#=Projection(DUI.NamespaceWindowsUIXamlInterop)#>;
+
+#pragma region "XamlMetaDataProvider"
+
+<#  if(!ProjectInfo.GenerateProviderCode) { #>
+    HRESULT XamlMetaDataProvider::AddOtherProvider(IXamlMetadataProvider* otherProvider)
+    {
+        HRESULT hr = _EnsureProvider();
+        if (SUCCEEDED(hr))
+        {
+            _provider->AddOtherProvider(otherProvider);
+        }
+
+        return hr;
+    }
+
+<#  }#>
+    HRESULT XamlMetaDataProvider::GetXamlType(TypeName type, IXamlType** result)
+    {
+        HRESULT hr = _EnsureProvider();
+        if (SUCCEEDED(hr))
+        {
+            hr = _provider->GetXamlTypeByType(type, result);
+        }
+
+        return hr;
+    }
+
+    HRESULT XamlMetaDataProvider::GetXamlTypeByFullName(HSTRING fullName, IXamlType** result)
+    {
+        HRESULT hr = _EnsureProvider();
+        if (SUCCEEDED(hr))
+        {
+            hr = _provider->GetXamlTypeByName(fullName, result);
+        }
+
+        return hr;
+    }
+
+    HRESULT XamlMetaDataProvider::GetXmlnsDefinitions(UINT32* resultLength, XmlnsDefinition** result)
+    {
+        *resultLength = 0;
+        *result = nullptr;
+        return S_OK;
+    }
+
+    HRESULT XamlMetaDataProvider::_EnsureProvider()
+    {
+        HRESULT hr = S_OK;
+
+        if (!_provider.Get())
+        {
+            hr = MakeAndInitialize<XamlTypeInfoProvider>(&_provider);
+        }
+
+        return hr;
+    }
+
+#pragma endregion "XamlSystemBaseType"
+
+#pragma region "XamlTypeInfoProvider"
+
+    HRESULT XamlTypeInfoProvider::GetXamlTypeByName(HSTRING typeName, IXamlType** ppXamlType)
+    {
+        *ppXamlType = nullptr;
+        HRESULT hr = TYPE_E_ELEMENTNOTFOUND;
+
+        const wchar_t* pszTypeName = WindowsGetStringRawBuffer(typeName, nullptr);
+        if (pszTypeName && *pszTypeName)
+        {
+            WeakRef xamlTypeWeak;
+            if (SUCCEEDED(_xamlTypes.GetItem(pszTypeName, xamlTypeWeak)))
+            {
+                ComPtr<IXamlType> xamlType;
+                if (SUCCEEDED(xamlTypeWeak.As(&xamlType)) && xamlType.Get())
+                {
+                    *ppXamlType = xamlType.Detach();
+                    hr = S_OK;
+                }
+            }
+
+            if (FAILED(hr))
+            {
+                ComPtr<IXamlType> xamlType;
+                ComPtr<IXamlUserType> userXamlType;
+                if (SUCCEEDED(_CreateXamlType(pszTypeName, &xamlType)) && xamlType.Get())
+                {
+                    xamlType.As(&userXamlType);
+                }
+
+                if (!xamlType.Get() || (userXamlType.Get() && userXamlType->IsReturnTypeStub() && !userXamlType->IsLocalType()))
+                {
+                    ComPtr<IXamlType> libXamlType;
+                    if (SUCCEEDED(_CheckOtherMetadataProvidersForName(typeName, &libXamlType)) && libXamlType.Get())
+                    {
+                        xamlType = libXamlType;
+                    }
+                }
+
+                if (xamlType.Get())
+                {
+                    *ppXamlType = xamlType.Detach();
+                    hr = S_OK;
+                }
+            }
+        }
+
+        if (hr == TYPE_E_ELEMENTNOTFOUND)
+        {
+            hr = S_OK; // The framework expects this function to return S_OK even if the type is not found
+        }
+
+        return hr;
+    }
+
+    HRESULT XamlTypeInfoProvider::GetXamlTypeByType(const TypeName& t, IXamlType** ppXamlType)
+    {
+        *ppXamlType = nullptr;
+        HRESULT hr = TYPE_E_ELEMENTNOTFOUND;
+
+        ComPtr<IXamlType> xamlType;
+        ComPtr<IXamlUserType> userXamlType;
+        if (SUCCEEDED(GetXamlTypeByName(t.Name, &xamlType)) && xamlType.Get())
+        {
+            xamlType.As(&userXamlType);
+        }
+
+        if (!xamlType.Get() || (userXamlType.Get() && userXamlType->IsReturnTypeStub() && !userXamlType->IsLocalType()))
+        {
+            ComPtr<IXamlType> libXamlType;
+            if (SUCCEEDED(_CheckOtherMetadataProvidersForType(t, &libXamlType)) && libXamlType.Get())
+            {
+                xamlType = libXamlType;
+            }
+        }
+
+        if (xamlType.Get())
+        {
+            *ppXamlType = xamlType.Detach();
+            hr = S_OK;
+        }
+
+        if (hr == TYPE_E_ELEMENTNOTFOUND)
+        {
+            hr = S_OK; // The framework expects this function to return S_OK even if the type is not found
+        }
+
+        return hr;
+    }
+
+    HRESULT XamlTypeInfoProvider::GetMemberByLongName(const wchar_t* longMemberName, IXamlMember** ppXamlMember)
+    {
+        *ppXamlMember = nullptr;
+        HRESULT hr = TYPE_E_ELEMENTNOTFOUND;
+
+        if (longMemberName && *longMemberName)
+        {
+            ComPtr<IXamlMember> xamlMember;
+            hr = _xamlMembers.GetItem(longMemberName, xamlMember);
+            if (FAILED(hr))
+            {
+                hr = _CreateXamlMember(longMemberName, &xamlMember);
+                if (SUCCEEDED(hr) && xamlMember.Get())
+                {
+                    _xamlMembers.SetItem(longMemberName, xamlMember);
+                }
+            }
+
+            if (SUCCEEDED(hr))
+            {
+                *ppXamlMember = xamlMember.Detach();
+            }
+        }
+
+        if (hr == TYPE_E_ELEMENTNOTFOUND)
+        {
+            hr = S_OK; // The framework expects this function to return S_OK even if the member is not found
+        }
+
+        return hr;
+    }
+<#  if(!ProjectInfo.GenerateProviderCode) { #>
+
+    HRESULT XamlTypeInfoProvider::AddOtherProvider(IXamlMetadataProvider* otherProvider)
+    {
+        return _otherProviders.Add(otherProvider);
+    }
+<#  }#>
+
+    HRESULT XamlTypeInfoProvider::_CheckOtherMetadataProvidersForName(HSTRING typeName, IXamlType** ppXamlType)
+    {
+        *ppXamlType = nullptr;
+        HRESULT hr = _EnsureOtherProviders();
+
+        ComPtr<IXamlType> foundXamlType;
+        for (size_t i = 0; SUCCEEDED(hr) && i < _otherProviders.GetSize(); ++i)
+        {
+            ComPtr<IXamlType> xamlType;
+            if (SUCCEEDED(_otherProviders[i]->GetXamlTypeByFullName(typeName, &xamlType)) && xamlType.Get())
+            {
+                foundXamlType = xamlType;
+
+                boolean bIsConstructible;
+                if (SUCCEEDED(xamlType->get_IsConstructible(&bIsConstructible)) && bIsConstructible)
+                {
+                    break;
+                }
+            }
+        }
+
+        if (SUCCEEDED(hr))
+        {
+            *ppXamlType = foundXamlType.Detach();
+        }
+
+        return hr;
+    }
+
+    HRESULT XamlTypeInfoProvider::_CheckOtherMetadataProvidersForType(const TypeName& t, IXamlType** ppXamlType)
+    {
+        *ppXamlType = nullptr;
+        HRESULT hr = _EnsureOtherProviders();
+
+        ComPtr<IXamlType> foundXamlType;
+        for (size_t i = 0; SUCCEEDED(hr) && i < _otherProviders.GetSize(); ++i)
+        {
+            ComPtr<IXamlType> xamlType;
+            if (SUCCEEDED(_otherProviders[i]->GetXamlType(t, &xamlType)) && xamlType.Get())
+            {
+                foundXamlType = xamlType;
+
+                boolean bIsConstructible;
+                if (SUCCEEDED(xamlType->get_IsConstructible(&bIsConstructible)) && bIsConstructible)
+                {
+                    break;
+                }
+            }
+        }
+
+        if (SUCCEEDED(hr))
+        {
+            *ppXamlType = foundXamlType.Detach();
+        }
+
+        return hr;
+    }
+
+#pragma endregion "XamlTypeInfoProvider"
+
+#pragma region "XamlSystemBaseType"
+
+    HRESULT XamlSystemBaseType::RuntimeClassInitialize(const wchar_t* name)
+    {
+        return _fullName.Set(name);
+    }
+
+    HRESULT XamlSystemBaseType::get_BaseType(IXamlType** value)
+    {
+        *value = nullptr;
+        return E_NOTIMPL;
+    }
+
+    HRESULT XamlSystemBaseType::get_ContentProperty(IXamlMember** value)
+    {
+        *value = nullptr;
+        return E_NOTIMPL;
+    }
+
+    HRESULT XamlSystemBaseType::get_FullName(HSTRING* value)
+    {
+        return _fullName.CopyTo(value);
+    }
+
+    HRESULT XamlSystemBaseType::get_IsArray(boolean* value)
+    {
+        *value = FALSE;
+        return E_NOTIMPL;
+    }
+
+    HRESULT XamlSystemBaseType::get_IsCollection(boolean* value)
+    {
+        *value = FALSE;
+        return E_NOTIMPL;
+    }
+
+    HRESULT XamlSystemBaseType::get_IsConstructible(boolean* value)
+    {
+        *value = FALSE;
+        return E_NOTIMPL;
+    }
+
+    HRESULT XamlSystemBaseType::get_IsDictionary(boolean* value)
+    {
+        *value = FALSE;
+        return E_NOTIMPL;
+    }
+
+    HRESULT XamlSystemBaseType::get_IsMarkupExtension(boolean* value)
+    {
+        *value = FALSE;
+        return E_NOTIMPL;
+    }
+
+    HRESULT XamlSystemBaseType::get_IsBindable(boolean* value)
+    {
+        *value = FALSE;
+        return E_NOTIMPL;
+    }
+
+    HRESULT XamlSystemBaseType::get_ItemType(IXamlType** value)
+    {
+        *value = nullptr;
+        return E_NOTIMPL;
+    }
+
+    HRESULT XamlSystemBaseType::get_KeyType(IXamlType** value)
+    {
+        *value = nullptr;
+        return E_NOTIMPL;
+    }
+
+    HRESULT XamlSystemBaseType::get_UnderlyingType(TypeName* value)
+    {
+        *value = {};
+
+        TypeName typeName;
+        HRESULT hr = _fullName.CopyTo(&typeName.Name);
+        if (SUCCEEDED(hr))
+        {
+            typeName.Kind = TypeKind_Primitive;
+            *value = typeName;
+        }
+
+        return hr;
+    }
+
+    HRESULT XamlSystemBaseType::ActivateInstance(::IInspectable** result)
+    {
+        *result = {};
+        return E_NOTIMPL;
+    }
+
+    HRESULT XamlSystemBaseType::CreateFromString(HSTRING, ::IInspectable** result)
+    {
+        *result = {};
+        return E_NOTIMPL;
+    }
+
+    HRESULT XamlSystemBaseType::GetMember(HSTRING, IXamlMember** result)
+    {
+        *result = {};
+        return E_NOTIMPL;
+    }
+
+    HRESULT XamlSystemBaseType::AddToVector(::IInspectable*, ::IInspectable*)
+    {
+        return E_NOTIMPL;
+    }
+
+    HRESULT XamlSystemBaseType::AddToMap(::IInspectable*, ::IInspectable*, ::IInspectable*)
+    {
+        return E_NOTIMPL;
+    }
+
+    HRESULT XamlSystemBaseType::RunInitializer()
+    {
+        return S_OK;
+    }
+
+    XamlUserType::~XamlUserType()
+    {
+        (void)_memberNames.Enum([](const wchar_t* pszK, const wchar_t* pszV) -> bool
+        {
+            delete[] (wchar_t*)pszK;
+            delete[] (wchar_t*)pszV;
+            return true;
+        });
+        (void)_enumValues.Enum([](const wchar_t* pszK, const ComPtr<::IInspectable>&) -> bool
+        {
+            delete[] (wchar_t*)pszK;
+            return true;
+        });
+    }
+
+    HRESULT XamlUserType::RuntimeClassInitialize(XamlTypeInfoProvider* provider, const wchar_t* fullName, IXamlType* baseType)
+    {
+        _provider = provider;
+        _baseType = baseType;
+        return _fullName.Set(fullName);
+    }
+
+    HRESULT XamlUserType::get_BaseType(IXamlType** value)
+    {
+        return _baseType.CopyTo(value);
+    }
+
+    HRESULT XamlUserType::get_ContentProperty(IXamlMember** value)
+    {
+        return _provider->GetMemberByLongName(_contentPropertyName.GetRawBuffer(nullptr), value);
+    }
+
+    HRESULT XamlUserType::get_FullName(HSTRING* value)
+    {
+        return _fullName.CopyTo(value);
+    }
+
+    HRESULT XamlUserType::get_IsArray(boolean* value)
+    {
+        *value = _isArray;
+        return S_OK;
+    }
+
+    HRESULT XamlUserType::get_IsCollection(boolean* value)
+    {
+        *value = _collectionAdd != nullptr;
+        return S_OK;
+    }
+
+    HRESULT XamlUserType::get_IsConstructible(boolean* value)
+    {
+        *value = _activator != nullptr;
+        return S_OK;
+    }
+
+    HRESULT XamlUserType::get_IsDictionary(boolean* value)
+    {
+        *value = _dictionaryAdd != nullptr;
+        return S_OK;
+    }
+
+    HRESULT XamlUserType::get_IsMarkupExtension(boolean* value)
+    {
+        *value = _isMarkupExtension;
+        return S_OK;
+    }
+
+    HRESULT XamlUserType::get_IsBindable(boolean* value)
+    {
+        *value = _isBindable;
+        return S_OK;
+    }
+
+    HRESULT XamlUserType::get_ItemType(IXamlType** value)
+    {
+        return _provider->GetXamlTypeByName(_itemTypeName, value);
+    }
+
+    HRESULT XamlUserType::get_KeyType(IXamlType** value)
+    {
+        return _provider->GetXamlTypeByName(_keyTypeName, value);
+    }
+
+    HRESULT XamlUserType::get_UnderlyingType(TypeName* value)
+    {
+        *value = {};
+
+        TypeName typeName;
+        HRESULT hr = _fullName.CopyTo(&typeName.Name);
+        if (SUCCEEDED(hr))
+        {
+            typeName.Kind = _kindOfType;
+            *value = typeName;
+        }
+
+        return hr;
+    }
+
+    HRESULT XamlUserType::ActivateInstance(::IInspectable** result)
+    {
+        return _activator(result);
+    }
+
+    HRESULT XamlUserType::CreateFromString(HSTRING value, ::IInspectable** result)
+    {
+        *result = nullptr;
+<#  if(Features.NullableTypes.ExistsInVersion(base.ProjectInfo.TargetPlatformMinVersion)) { #>
+        {
+            // For boxed types, run the boxed type's CreateFromString method and boxing
+            ComPtr<IXamlType> boxedType;
+            if (SUCCEEDED(get_BoxedType(&boxedType)) && boxedType.Get())
+            {
+                return boxedType->CreateFromString(value, result);
+            }
+        }
+<#  } #>
+
+        if (_createFromStringMethod)
+        {
+            return (*_createFromStringMethod)(value, result);
+        }
+        else
+        {
+            return _fromStringConverter(this, value, result);
+        }
+    }
+
+    HRESULT XamlUserType::GetMember(HSTRING name, IXamlMember** result)
+    {
+        *result = nullptr;
+        HRESULT hr = TYPE_E_ELEMENTNOTFOUND;
+
+        const wchar_t* pszName = WindowsGetStringRawBuffer(name, nullptr);
+        if (pszName && *pszName)
+        {
+            const wchar_t* val;
+            hr = _memberNames.GetItem(pszName, val);
+            if (SUCCEEDED(hr))
+            {
+                hr = _provider->GetMemberByLongName(val, result);
+            }
+        }
+
+        if (hr == TYPE_E_ELEMENTNOTFOUND)
+        {
+            hr = S_OK; // The framework expects this function to return S_OK even if the member is not found
+        }
+
+        return hr;
+    }
+
+    HRESULT XamlUserType::AddToVector(::IInspectable* instance, ::IInspectable* value)
+    {
+        return _collectionAdd(instance, value);
+    }
+
+    HRESULT XamlUserType::AddToMap(::IInspectable* instance, ::IInspectable* key, ::IInspectable* value)
+    {
+        return _dictionaryAdd(instance, key, value);
+    }
+
+    HRESULT XamlUserType::RunInitializer()
+    {
+        // The C++ runtime will have already run all the Static Initializers at start up.
+        return S_OK;
+    }
+<#  if(Features.NullableTypes.ExistsInVersion(base.ProjectInfo.TargetPlatformMinVersion)) { #>
+
+    HRESULT XamlUserType::get_BoxedType(IXamlType** value)
+    {
+        return _boxedType.CopyTo(value);
+    }
+<#  } #>
+
+    void XamlUserType::SetArray(bool value)
+    {
+        _isArray = value;
+    }
+
+    void XamlUserType::SetMarkupExtension(bool value)
+    {
+        _isMarkupExtension = value;
+    }
+
+    void XamlUserType::SetEnum(bool value)
+    {
+        _isEnum = value;
+    }
+
+    void XamlUserType::SetBindable(bool value)
+    {
+        _isBindable = value;
+    }
+
+    bool XamlUserType::IsReturnTypeStub() const
+    {
+        return _isReturnTypeStub;
+    }
+
+    void XamlUserType::SetReturnTypeStub(bool value)
+    {
+        _isReturnTypeStub = value;
+    }
+
+    bool XamlUserType::IsLocalType() const
+    {
+        return _isLocalType;
+    }
+
+    void XamlUserType::SetLocalType(bool value)
+    {
+        _isLocalType = value;
+    }
+
+    HRESULT XamlUserType::SetContentPropertyName(const wchar_t* value)
+    {
+        return _contentPropertyName.Set(value);
+    }
+
+    HRESULT XamlUserType::SetItemTypeName(const wchar_t* value)
+    {
+        return _itemTypeName.Set(value);
+    }
+
+    HRESULT XamlUserType::SetKeyTypeName(const wchar_t* value)
+    {
+        return _keyTypeName.Set(value);
+    }
+
+<#  if(Features.NullableTypes.ExistsInVersion(base.ProjectInfo.TargetPlatformMinVersion)) { #>
+    void XamlUserType::SetBoxedType(IXamlType* boxedType)
+    {
+        _boxedType = boxedType;
+    }
+
+<#  } #>
+    HRESULT XamlUserType::AddMemberName(const wchar_t* pszShortName)
+    {
+        HRESULT hr = E_OUTOFMEMORY;
+
+        UINT cchShortName = pszShortName ? (UINT)wcslen(pszShortName) : 0;
+        if (!pszShortName)
+        {
+            pszShortName = L"";
+        }
+
+        UINT cchFullName = 0;
+        const wchar_t* pszFullName = _fullName.GetRawBuffer(&cchFullName);
+        if (!pszFullName)
+        {
+            pszFullName = L"";
+        }
+
+        size_t cchValue = cchFullName + 1 /*.*/ + cchShortName;
+        size_t cbValue = sizeof(wchar_t) * (cchValue + 1 /*NUL*/);
+        wchar_t* pszValue = new wchar_t[cbValue / sizeof(wchar_t)];
+        if (pszValue)
+        {
+            memcpy_s(pszValue, cbValue, pszFullName, sizeof(wchar_t) * cchFullName);
+            pszValue[cchFullName] = L'.';
+            memcpy_s(pszValue + cchFullName + 1 /*.*/, cbValue, pszShortName, sizeof(wchar_t) * cchShortName);
+            pszValue[cchFullName + 1 /*.*/ + cchShortName] = 0;
+
+            size_t cchKey = cchShortName;
+            size_t cbKey = sizeof(wchar_t) * (cchKey + 1 /*NUL*/);
+            wchar_t* pszKey = new wchar_t[cbKey / sizeof(wchar_t)];
+            if (pszKey)
+            {
+                memcpy_s(pszKey, cbKey, pszShortName, sizeof(wchar_t) * cchShortName);
+                pszKey[cchShortName] = 0;
+
+                hr = _memberNames.SetItem(pszKey, pszValue);
+                if (SUCCEEDED(hr))
+                {
+                    pszKey = pszValue = nullptr;
+                }
+
+                if (pszKey)
+                {
+                    delete[] pszKey;
+                }
+            }
+
+            if (pszValue)
+            {
+                delete[] pszValue;
+            }
+        }
+
+        return hr;
+    }
+
+    HRESULT XamlUserType::AddEnumValue(const wchar_t* name, ::IInspectable* value)
+    {
+        if (!name || !*name || !value)
+        {
+            return E_INVALIDARG;
+        }
+
+        HRESULT hr = E_OUTOFMEMORY;
+
+        size_t cchName = name ? wcslen(name) : 0;
+        size_t cbName = sizeof(wchar_t) * (cchName + 1 /*NUL*/);
+        wchar_t* pszKey = new wchar_t[cbName / sizeof(wchar_t)];
+        if (pszKey)
+        {
+            memcpy_s(pszKey, cbName, name, sizeof(wchar_t) * cchName);
+            pszKey[cchName] = 0;
+
+            hr = _enumValues.SetItem(pszKey, value);
+            if (SUCCEEDED(hr))
+            {
+                pszKey = nullptr;
+            }
+
+            if (pszKey)
+            {
+                delete[] pszKey;
+            }
+        }
+
+        return hr;
+    }
+
+    HRESULT XamlUserType::CreateEnumUIntFromString(HSTRING input, UINT* result) const
+    {
+        *result = 0;
+        bool fFound = false;
+
+        const wchar_t* pszInput = WindowsGetStringRawBuffer(input, nullptr);
+        if (!pszInput || !*pszInput)
+        {
+            return E_INVALIDARG;
+        }
+
+        const wchar_t* pszCur = pszInput;
+
+        while (*pszCur)
+        {
+            // Skip leading whitespace
+            while (*pszCur && iswspace(*pszCur))
+            {
+                ++pszCur;
+            }
+
+            const wchar_t* pszTokenStart = pszCur;
+
+            // Find end of token (either comma or null terminator)
+            while (*pszCur && *pszCur != L',')
+            {
+                ++pszCur;
+            }
+
+            const wchar_t* pszTokenEnd = pszCur;
+
+            // Trim trailing whitespace
+            while (pszTokenEnd > pszTokenStart && iswspace(*(pszTokenEnd - 1)))
+            {
+                --pszTokenEnd;
+            }
+
+            // Skip empty tokens
+            if (pszTokenStart < pszTokenEnd)
+            {
+                size_t cchToken = static_cast<size_t>(pszTokenEnd - pszTokenStart);
+                wchar_t szTokenBuffer[128]; // assume tokens won't exceed 127 chars
+                szTokenBuffer[0] = 0;
+
+                if (cchToken >= _countof(szTokenBuffer))
+                {
+                    return E_INVALIDARG;
+                }
+
+                HRESULT hr = StringCchCopyNW(szTokenBuffer, ARRAYSIZE(szTokenBuffer), pszTokenStart, cchToken);
+                if (FAILED(hr))
+                {
+                    return hr;
+                }
+
+                // Try to get enum value from dictionary
+                ComPtr<IInspectable> spValueBoxed;
+                hr = _enumValues.GetItem(szTokenBuffer, spValueBoxed);
+                if (SUCCEEDED(hr))
+                {
+                    int value = 0;
+                    hr = TroleBoxer::UnboxValue<int>(spValueBoxed.Get(), &value);
+                    if (FAILED(hr))
+                    {
+                        return hr;
+                    }
+                    *result |= static_cast<UINT>(value);
+                    fFound = true;
+                }
+                else
+                {
+                    // Try to parse it as an integer
+                    UINT value = 0;
+                    for (size_t i = 0; i < cchToken; ++i)
+                    {
+                        wchar_t ch = pszTokenStart[i];
+                        if (ch >= L'0' && ch <= L'9')
+                        {
+                            value = value * 10 + (ch - L'0');
+                        }
+                        else
+                        {
+                            return E_INVALIDARG;
+                        }
+                    }
+
+                    *result |= value;
+                    fFound = true;
+                }
+            }
+
+            // Skip comma
+            if (*pszCur == L',')
+            {
+                ++pszCur;
+            }
+        }
+
+        return fFound ? S_OK : E_INVALIDARG;
+    }
+
+#pragma endregion "XamlSystemBaseType"
+
+#pragma region "XamlMember"
+
+    XamlMember::XamlMember()
+    {
+    }
+
+    HRESULT XamlMember::RuntimeClassInitialize(XamlTypeInfoProvider* provider, const wchar_t* name, const wchar_t* typeName)
+    {
+        _provider = provider;
+        HRESULT hr = _name.Set(name);
+        if (SUCCEEDED(hr))
+        {
+            hr = _typeName.Set(typeName);
+        }
+        return hr;
+    }
+
+    HRESULT XamlMember::get_IsAttachable(boolean* value)
+    {
+        *value = _isAttachable;
+        return S_OK;
+    }
+
+    HRESULT XamlMember::get_IsDependencyProperty(boolean* value)
+    {
+        *value = _isDependencyProperty;
+        return S_OK;
+    }
+
+    HRESULT XamlMember::get_IsReadOnly(boolean* value)
+    {
+        *value = _isReadOnly;
+        return S_OK;
+    }
+
+    HRESULT XamlMember::get_Name(HSTRING* value)
+    {
+        return _name.CopyTo(value);
+    }
+
+    HRESULT XamlMember::get_TargetType(IXamlType** value)
+    {
+        return _provider->GetXamlTypeByName(_targetTypeName, value);
+    }
+
+    HRESULT XamlMember::get_Type(IXamlType** value)
+    {
+        return _provider->GetXamlTypeByName(_typeName, value);
+    }
+
+    HRESULT XamlMember::GetValue(::IInspectable* instance, ::IInspectable** result)
+    {
+        return _getter(instance, result);
+    }
+
+    HRESULT XamlMember::SetValue(::IInspectable* instance, ::IInspectable* value)
+    {
+        return _setter(instance, value);
+    }
+
+    HRESULT XamlMember::SetTargetTypeName(const wchar_t* value)
+    {
+        return _targetTypeName.Set(value);
+    }
+
+    void XamlMember::SetAttachable(bool value)
+    {
+        _isAttachable = value;
+    }
+
+    void XamlMember::SetDependencyProperty(bool value)
+    {
+        _isDependencyProperty = value;
+    }
+
+    void XamlMember::SetReadOnly(bool value)
+    {
+        _isReadOnly = value;
+    }
+
+#pragma endregion "XamlMember"
+
+}
